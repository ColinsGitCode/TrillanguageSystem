const fs = require('fs');
const path = require('path');

// ========== Few-shot 示例库 ==========
const FEWSHOT_EXAMPLES = {
    // 示例 1: 日常简单词汇
    daily: {
        input: "打招呼",
        output: `# 打招呼

## 1. 英文:
- **翻译**: greet / say hello
- **解释**: A polite action of acknowledging someone when you meet them
- **例句1**: Hey, I just wanted to greet the new neighbors.
  - 嘿，我只是想跟新邻居打个招呼。
- **例句2**: Don't forget to greet your teacher when you see her.
  - 见到老师时别忘了打招呼。

## 2. 日本語:
- **翻訳**: 挨拶(あいさつ)する
- **解説**: 人(ひと)に会(あ)った時(とき)に礼儀(れいぎ)として声(こえ)をかける行為(こうい)
- **例句1**: 朝(あさ)、会社(かいしゃ)で同僚(どうりょう)に挨拶(あいさつ)するのは基本(きほん)だよ。
  - 早上在公司向同事打招呼是基本礼仪。
- **例句2**: 彼(かれ)はいつも笑顔(えがお)で挨拶(あいさつ)してくれる。
  - 他总是笑着跟我打招呼。

## 3. 中文:
- **翻译**: 打招呼 [原文]
- **解释**: 见面时表示问候的礼貌行为`
    },

    // 示例 2: 技术术语
    technical: {
        input: "API",
        output: `# API

## 1. 英文:
- **翻译**: API (Application Programming Interface) [原文]
- **解释**: A set of rules allowing different software to communicate
- **例句1**: We need to integrate their payment API into our app.
  - 我们需要把他们的支付 API 集成到我们的应用里。
- **例句2**: This API documentation is really well written.
  - 这个 API 文档写得真不错。

## 2. 日本語:
- **翻訳**: API（エーピーアイ）/ アプリケーション・プログラミング・インターフェース
- **解説**: ソフトウェア同士(どうし)が通信(つうしん)するためのルール集(しゅう)
- **例句1**: この API(エーピーアイ)を使(つか)えば、簡単(かんたん)にデータを取得(しゅとく)できます。
  - 使用这个 API 就能轻松获取数据。
- **例句2**: REST API(レスト・エーピーアイ)の設計(せっけい)について勉強(べんきょう)してるんだ。
  - 我正在学习 REST API 的设计。

## 3. 中文:
- **翻译**: 应用程序编程接口
- **解释**: 允许不同软件系统相互通信的一组规则和协议

## 4. 技术概念简要说明
应用程序编程接口（API）是一组预定义的函数、协议和工具，允许不同的软件系统相互通信和交换数据。它定义了软件组件之间交互的方式，隐藏了内部实现细节，只暴露必要的接口。常见类型包括 REST API、GraphQL API 等。开发者通过调用 API 可以实现跨系统的功能集成，如第三方登录、支付、地图服务等。API 的设计质量直接影响系统的可维护性和扩展性。`
    },

    // 示例 3: 多义词
    ambiguous: {
        input: "run",
        output: `# run

## 1. 英文:
- **翻译**: run [原文]
- **解释**: To move fast on foot; also means to operate programs or manage businesses
- **例句1**: I usually run in the park every morning.
  - 我通常每天早上在公园跑步。
- **例句2**: Can you run this script and see if it works?
  - 你能运行这个脚本看看是否正常吗？

## 2. 日本語:
- **翻訳**: 走(はし)る / 実行(じっこう)する / 運営(うんえい)する
- **解説**: 足(あし)を速(はや)く動(うご)かして移動(いどう)すること、またはプログラムを動(うご)かすこと
- **例句1**: 毎朝(まいあさ)30分(ぷん)くらい走(はし)ってるよ。
  - 我每天早上跑步大约30分钟。
- **例句2**: このプログラムを実行(じっこう)してみて。
  - 试试运行这个程序。

## 3. 中文:
- **翻译**: 跑步 / 运行 / 经营
- **解释**: 快速移动的动作，也指程序执行或业务运营`
    },

    // 示例 4: 日语输入（重要：展示日语输入的正确格式）
    japanese: {
        input: "こんにちは",
        output: `# こんにちは

## 1. 英文:
- **翻译**: Hello / Hi
- **解释**: A common Japanese greeting used during the day
- **例句1**: Hello, how are you doing today?
  - 你好，你今天过得怎么样？
- **例句2**: Hi there, nice to meet you!
  - 嗨，很高兴见到你！

## 2. 日本語:
- **翻訳**: こんにちは [原文]
- **解説**: 昼間(ひるま)に使(つか)う一般的(いっぱんてき)な挨拶(あいさつ)
- **例句1**: こんにちは、お元気(げんき)ですか？
  - 你好，你还好吗？
- **例句2**: こんにちは、初(はじ)めまして！
  - 你好，初次见面！

## 3. 中文:
- **翻译**: 你好
- **解释**: 日语中白天使用的常见问候语`
    }
};

// ========== 提示词构建函数 ==========

/**
 * 构建完整的三语翻译提示词（完整优化版）
 *
 * @param {Object} args - 参数对象
 * @param {string} args.phrase - 待翻译的短语
 * @param {string} args.filenameBase - 生成文件的基础名称
 * @returns {string} 完整的提示词
 */
function buildPrompt(args) {
    const phrase = args.phrase || '';
    const filenameBase = args.filenameBase || '';

    // ========== 第一部分：系统角色和任务定义 ==========
    const systemRole = `你是一位专业的多语言翻译和语言教学助手，精通中文、英文、日语三种语言。
你的专长包括：
- 准确识别和翻译三种语言之间的表达
- 创作自然、地道、实用的例句
- 理解多义词的语境并准确消歧
- 提供符合母语习惯的高质量翻译`;

    // ========== 第二部分：Chain of Thought 推理引导 ==========
    const cotGuidance = `
## 推理步骤（内部思考，不输出）

在生成最终内容前，请按以下步骤思考：

**步骤 1：语言识别与词性分析**
- 识别输入短语的主要语言（中文/英文/日语）
- 分析词性（名词/动词/形容词/短语/句子）
- 识别是否存在拼写错误，若有则先修正

**步骤 2：多义词消歧与语境理解**
- 判断是否为多义词（如 "run" 可以是跑步/运行/经营）
- 如果是多义词，列举主要义项，选择最常用的含义
- 如果有特定领域倾向（如技术术语），优先考虑该领域含义

**步骤 3：翻译策略选择**
- 确定每种目标语言的翻译策略（直译/意译/音译）
- 考虑文化差异和习语特点
- 对于技术术语，保持术语一致性

**步骤 4：例句场景规划**
- 规划两个例句的使用场景（第一句偏正式/工作，第二句偏日常/轻松）
- 确保例句难度与短语难度匹配
- 确保两个例句展示不同的使用场景，避免重复

**步骤 5：质量自检**
- 检查翻译准确性和自然度
- 检查例句是否符合口语风格
- 检查日语汉字是否都有假名注音
- 检查外来语是否标注了原语言`;

    // ========== 第三部分：Few-shot 示例 ==========
    const fewshotSection = `
## 高质量示例参考

以下是四个不同类型短语的标准输出示例，请严格参考这些示例的质量和格式：

### 示例 1：日常词汇（中文输入）
输入短语："${FEWSHOT_EXAMPLES.daily.input}"

期望输出：
\`\`\`markdown
${FEWSHOT_EXAMPLES.daily.output}
\`\`\`

### 示例 2：技术术语（英文输入）
输入短语："${FEWSHOT_EXAMPLES.technical.input}"

期望输出：
\`\`\`markdown
${FEWSHOT_EXAMPLES.technical.output}
\`\`\`

### 示例 3：多义词处理（英文输入）
输入短语："${FEWSHOT_EXAMPLES.ambiguous.input}"

期望输出：
\`\`\`markdown
${FEWSHOT_EXAMPLES.ambiguous.output}
\`\`\`

### 示例 4：日语输入（重要参考）
输入短语："${FEWSHOT_EXAMPLES.japanese.input}"

**注意**：当输入是日语时，英文部分的例句必须是英语，不能是日语！

期望输出：
\`\`\`markdown
${FEWSHOT_EXAMPLES.japanese.output}
\`\`\``;

    // ========== 第四部分：详细的输出要求 ==========
    const detailedRequirements = `
## 当前任务

请为以下短语生成三语学习卡片：

**输入短语**: "${phrase}"

---

## 输出要求详解

### 1. 翻译质量标准

- **准确性**：翻译必须准确传达原意，不添加或遗漏信息
- **自然度**：使用母语者日常使用的表达，避免生硬的直译
- **语域匹配**：保持与原短语相同的正式度（正式/非正式/中性）
- **简洁性**：翻译应简洁明了，避免冗长表达

**⚠️ 语言分离原则（非常重要）：**
- 英文部分的例句**必须是英语**，不能是中文或日语
- 日语部分的例句**必须是日语**，不能是中文或英语
- 中文翻译**必须是纯中文**，不能包含Ruby标签或假名注音
- 每种语言各司其职，严格分离

### 2. 例句黄金标准（5个维度）

| 维度 | 要求 | 说明 |
|------|------|------|
| **场景真实性** | 必须是日常可能遇到的真实场景 | ✓ 可以直接使用的句子 ✗ 人为造句感 |
| **长度控制** | 英文 8-15 词，日语 10-20 字 | 既不过短也不过长 |
| **难度适配** | 与短语难度匹配±1级 | 避免短语简单但例句复杂 |
| **语法自然** | 使用口语表达和缩写 | "Wanna grab lunch?" ✓ "Do you desire food?" ✗ |
| **场景多样** | 两个例句覆盖不同场景 | 例句1工作场景，例句2日常场景 |

**例句创作指南：**
- 第一句：偏向正式/工作/学习场景
- 第二句：偏向日常/轻松/生活场景
- 使用缩写和口语表达（如 wanna, gonna, isn't）
- 避免过于复杂的从句结构
- 确保学习者可以直接套用这个句型

### 3. 日语特殊规则

**Ruby 注音规则：**
- ✓ 所有汉字必须标注假名：漢字(かんじ)
- ✓ 每个汉字独立注音：勉(べん)強(きょう)
- ✓ 专有名词可整体注音：東京(とうきょう)
- ✓ 送假名动词只注汉字部分：食(た)べる
- ✗ 英文缩写不注音：API、IT、URL
- ✓ **外来语片假名必须标注英文原词**：コンピュータ(computer)、テスト(test)

**⚠️ 重要：外来语标注规则**
- 所有片假名外来语（如テスト、データ、サーバー）都必须在括号中标注对应的英文
- 即使是常用词也不能省略：テスト(test)、データ(data)、サーバー(server)
- 这是强制要求，不可遗漏

**⚠️ 重要：例句中文翻译规则**
- 日语例句后的"中文翻译"必须是真正的汉语，不能是日语
- ❌ 错误示例：このコードを試験する必要があります。（这是日语同义替换）
- ✅ 正确示例：需要测试这段代码。（这才是中文）
- 翻译时要将日语完整转换为中文，而不是替换个别词汇
- **中文翻译中不允许出现任何日语注音/假名/括号读音**（例如：汉字(かな) 这种形式禁止）

**语域选择：**
- 例句1：使用です/ます体（礼貌体）
- 例句2：使用普通体（日常体）
- 避免过度敬语（謙譲語/尊敬語）

### 4. 解释说明标准

- **长度**：中文不超过20字，英文不超过15词，日语不超过25字
- **内容**：简要说明含义或使用场景，不要复述翻译
- **角度**：可以说明用法、场景、语境、文化背景等

### 5. 技术概念说明（可选）

如果短语是 IT/技术/专业领域的术语：
- 提供中文简要说明（约200字）
- 包括：定义、应用场景、常见类型、实际用途
- 使用通俗易懂的语言，避免过于学术化`;

    // ========== 第五部分：输出格式和 JSON 结构 ==========
    const outputFormat = `
## 输出格式

请严格按照以下 Markdown 格式输出：

\`\`\`markdown
# ${phrase}

## 1. 英文:
- **翻译**: [英文翻译]
- **解释**: [一句话英文解释，不超过15词]
- **例句1**: [必须是英语句子，不能是中文或日语]
  - [例句的中文翻译 - 纯中文，无任何标签]
- **例句2**: [必须是英语句子，不能是中文或日语]
  - [例句的中文翻译 - 纯中文，无任何标签]

## 2. 日本語:
- **翻訳**: [日语翻译，汉字需注音如：漢字(かんじ)，片假名外来语标注英文如：テスト(test)]
- **解説**: [日语解释，汉字需注音，外来语标注英文]
- **例句1**: [必须是日语句子，汉字注音，外来语标注如：データ(data)]
  - [纯中文翻译 - 不要Ruby标签/假名/括号注音，只要汉字/中文]
- **例句2**: [必须是日语句子，汉字注音，外来语标注如：サーバー(server)]
  - [纯中文翻译 - 不要Ruby标签/假名/括号注音，只要汉字/中文]

## 3. 中文:
- **翻译**: [中文翻译]
- **解释**: [一句话中文解释]

## 4. 技术概念简要说明
[如果是技术术语，提供200字左右的中文说明；否则省略此节]
\`\`\`

---

## 最终输出格式（JSON）

你必须返回一个有效的 JSON 对象，包含以下字段：

\`\`\`json
{
  "markdown_content": "完整的 Markdown 内容（按上述格式）",
  "audio_tasks": [
    { "text": "英文例句1原文（不含标点）", "lang": "en", "filename_suffix": "_en_1" },
    { "text": "英文例句2原文（不含标点）", "lang": "en", "filename_suffix": "_en_2" },
    { "text": "日语例句1原文（不含ruby标签的纯文本）", "lang": "ja", "filename_suffix": "_ja_1" },
    { "text": "日语例句2原文（不含ruby标签的纯文本）", "lang": "ja", "filename_suffix": "_ja_2" }
  ]
}
\`\`\`

**重要说明：**
1. \`markdown_content\` 中的换行用 \\n 转义
2. \`markdown_content\` 中的双引号用 \\" 转义
3. \`audio_tasks\` 中的日语文本不要包含 ruby 标签，只要纯文本（TTS 无法处理标签）
4. \`audio_tasks\` 中的英文文本去除句末标点符号（如 . ! ?）
5. 文件名基础: "${filenameBase}"

**禁止内容：**
- 禁止包含 <script>、<iframe>、<object>、<embed> 标签
- 禁止引用外部资源（CDN、外部 CSS/JS）

---

## 质量自检清单

生成内容后，请在内部确认以下检查点（不输出）：

- [ ] 三语翻译准确且自然
- [ ] 例句符合口语风格（使用缩写和日常表达）
- [ ] 两个例句场景不重复（一个正式，一个日常）
- [ ] 例句长度符合标准（英文8-15词，日语10-20字）
- [ ] 日语汉字都有假名注音（ruby格式正确）
- [ ] **日语所有外来语片假名都标注了英文原词**（如：テスト(test)、データ(data)）
- [ ] **日语例句的中文翻译是真正的中文**（不是日语同义词替换）
- [ ] **日语例句的中文翻译不含假名/括号注音**（不出现“汉字(かな)”形式）
- [ ] audio_tasks 中的文本是纯文本（无ruby标签，无标点）
- [ ] JSON 格式正确（换行和引号已转义）

---

现在请开始生成内容。`;

    // ========== 组合完整提示词 ==========
    return `${systemRole}

${cotGuidance}

${fewshotSection}

${detailedRequirements}

${outputFormat}`;
}

module.exports = { buildPrompt };

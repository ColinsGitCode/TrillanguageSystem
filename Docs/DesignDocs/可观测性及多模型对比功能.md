# å¯è§‚æµ‹æ€§åŠå¤šæ¨¡å‹å¯¹æ¯”åŠŸèƒ½è®¾è®¡æ–‡æ¡£

> **é¡¹ç›®åç§°**: Trilingual Records Viewer - AI Agent å¯è§‚æµ‹æ€§å¢å¼º
> **ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¥æœŸ**: 2026-02-02
> **ä½œè€…**: Claude & Team

---

## ğŸ“‹ ç›®å½•

- [1. åŠŸèƒ½æ¦‚è¿°](#1-åŠŸèƒ½æ¦‚è¿°)
- [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
- [3. æ•°æ®ç»“æ„è®¾è®¡](#3-æ•°æ®ç»“æ„è®¾è®¡)
- [4. åç«¯è®¾è®¡](#4-åç«¯è®¾è®¡)
- [5. å‰ç«¯è®¾è®¡](#5-å‰ç«¯è®¾è®¡)
- [6. å®ç°æ­¥éª¤](#6-å®ç°æ­¥éª¤)
- [7. æµ‹è¯•è®¡åˆ’](#7-æµ‹è¯•è®¡åˆ’)

---

## 1. åŠŸèƒ½æ¦‚è¿°

æœ¬æ¬¡ä¼˜åŒ–æ—¨åœ¨ä¸º AI é©±åŠ¨çš„ä¸‰è¯­å¡ç‰‡ç”Ÿæˆç³»ç»Ÿå¢å¼º**å¯è§‚æµ‹æ€§ï¼ˆObservabilityï¼‰**ï¼Œå¸®åŠ©ç”¨æˆ·ï¼š
- ç†è§£ AI ç”Ÿæˆè¿‡ç¨‹
- ç›‘æ§ç³»ç»Ÿæ€§èƒ½ä¸å¥åº·çŠ¶æ€
- è¯„ä¼°å†…å®¹è´¨é‡
- å¯¹æ¯”ä¸åŒ LLM æä¾›å•†æ•ˆæœ

### 1.1 åŠŸèƒ½åˆ—è¡¨ï¼ˆä¼˜å…ˆçº§æ’åºï¼‰

| ç¼–å· | åŠŸèƒ½åç§° | ä¼˜å…ˆçº§ | ä»·å€¼ |
|------|---------|--------|------|
| F1 | Token è®¡æ•°ä¸æˆæœ¬ä¼°ç®— | ğŸ”¥ é«˜ | é…é¢ç®¡ç†ã€æˆæœ¬æ§åˆ¶ |
| F2 | æ€§èƒ½æŒ‡æ ‡ä»ªè¡¨ç›˜ | ğŸ”¥ é«˜ | æ€§èƒ½ä¼˜åŒ–ã€ç“¶é¢ˆå®šä½ |
| F3 | æœåŠ¡çŠ¶æ€é¢æ¿ | ğŸ”¥ é«˜ | æ•…éšœé¢„è­¦ã€å¥åº·ç›‘æ§ |
| F5 | Prompt ç»“æ„åŒ–å±•ç¤º | â­ ä¸­ | Prompt å·¥ç¨‹ã€è°ƒè¯• |
| F7 | å†…å®¹è´¨é‡è¯„åˆ† | â­ ä¸­ | è´¨é‡ä¿éšœã€è‡ªåŠ¨åŒ–æ£€æŸ¥ |
| F9 | å¤šæ¨¡å‹å¯¹æ¯”æ¨¡å¼ | â­ ä¸­ | A/B æµ‹è¯•ã€æ¨¡å‹é€‰æ‹© |

---

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         å‰ç«¯ (Frontend)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚  å¯è§‚æµ‹æ€§é¢æ¿     â”‚  â”‚  å¯¹æ¯”æ¨¡å¼é¢æ¿     â”‚                 â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                 â”‚
â”‚  â”‚ â€¢ Token Stats    â”‚  â”‚ â€¢ Gemini Output  â”‚                 â”‚
â”‚  â”‚ â€¢ Performance    â”‚  â”‚ â€¢ Local Output   â”‚                 â”‚
â”‚  â”‚ â€¢ Health Status  â”‚  â”‚ â€¢ Side-by-Side   â”‚                 â”‚
â”‚  â”‚ â€¢ Prompt View    â”‚  â”‚ â€¢ Metrics Compareâ”‚                 â”‚
â”‚  â”‚ â€¢ Quality Score  â”‚  â”‚                  â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ HTTP/JSON
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åç«¯ API (Backend)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            /api/generate (Enhanced)                   â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚ â€¢ Accept: { phrase, llm_provider, enable_compare }   â”‚   â”‚
â”‚  â”‚ â€¢ Return: { result, observability, comparison }      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            /api/health (New)                          â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚ â€¢ Check: Gemini, Local LLM, TTS Services             â”‚   â”‚
â”‚  â”‚ â€¢ Return: { services[], quota, storage }             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Observability   â”‚          â”‚   LLM Services   â”‚
â”‚     Module       â”‚          â”‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ tokenCounter   â”‚          â”‚ â€¢ geminiService  â”‚
â”‚ â€¢ perfMonitor    â”‚          â”‚ â€¢ localLlmServiceâ”‚
â”‚ â€¢ qualityChecker â”‚          â”‚                  â”‚
â”‚ â€¢ healthChecker  â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ•°æ®æµ

```
ç”¨æˆ·è¾“å…¥ Phrase
    â”‚
    â–¼
å‰ç«¯æ”¶é›†é…ç½® (provider, enable_compare)
    â”‚
    â–¼
POST /api/generate
    â”‚
    â”œâ”€â”€[å•æ¨¡å‹æ¨¡å¼]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                â”‚
    â”‚   1. Build Prompt              â”‚
    â”‚   2. Call LLM Service          â”‚
    â”‚   3. Parse Response            â”‚
    â”‚   4. Quality Check â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚   5. Token Count           â”‚   â”‚
    â”‚   6. Performance Metrics   â”‚   â”‚
    â”‚                            â”‚   â”‚
    â”‚   Return {                 â”‚   â”‚
    â”‚     result,                â”‚   â”‚
    â”‚     observability {        â”‚   â”‚
    â”‚       tokens,        â—„â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚       performance,             â”‚
    â”‚       quality                  â”‚
    â”‚     }                          â”‚
    â”‚   }                            â”‚
    â”‚                                â”‚
    â””â”€â”€[å¯¹æ¯”æ¨¡å¼]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚                            â”‚
        â”œâ”€â–º Call Gemini â”€â”€â”          â”‚
        â”‚                 â”‚          â”‚
        â”œâ”€â–º Call Local â”€â”€â”€â”¤          â”‚
        â”‚                 â”‚          â”‚
        â””â”€â–º Aggregate â—„â”€â”€â”€â”˜          â”‚
            Return {                 â”‚
              comparison {           â”‚
                gemini: {...},       â”‚
                local: {...}         â”‚
              }                      â”‚
            }                        â”‚
                                     â”‚
                                     â–¼
                            è¿”å›å‰ç«¯æ¸²æŸ“
```

---

## 3. æ•°æ®ç»“æ„è®¾è®¡

### 3.1 å¯è§‚æµ‹æ€§æ•°æ®ç»“æ„ (ObservabilityData)

```typescript
interface ObservabilityData {
  // ===== F1: Token è®¡æ•°ä¸æˆæœ¬ =====
  tokens: {
    input: number;           // è¾“å…¥ tokens
    output: number;          // è¾“å‡º tokens
    total: number;           // æ€» tokens
    cached?: number;         // ç¼“å­˜ tokens (Gemini)
  };

  cost: {
    input: number;           // è¾“å…¥æˆæœ¬ (USD)
    output: number;          // è¾“å‡ºæˆæœ¬ (USD)
    total: number;           // æ€»æˆæœ¬ (USD)
  };

  quota: {
    used: number;            // ä»Šæ—¥å·²ä½¿ç”¨
    limit: number;           // ä»Šæ—¥é™é¢
    remaining: number;       // å‰©ä½™é¢åº¦
    resetAt: string;         // é‡ç½®æ—¶é—´ (ISO 8601)
    percentage: number;      // ä½¿ç”¨ç™¾åˆ†æ¯”
  };

  // ===== F2: æ€§èƒ½æŒ‡æ ‡ =====
  performance: {
    totalTime: number;       // æ€»è€—æ—¶ (ms)
    phases: {
      promptBuild: number;   // Prompt æ„å»º
      llmCall: number;       // LLM è°ƒç”¨
      jsonParse: number;     // JSON è§£æ
      fileSave: number;      // æ–‡ä»¶ä¿å­˜
      audioGenerate?: number;// éŸ³é¢‘ç”Ÿæˆ (å¯é€‰)
    };
    networkLatency: number;  // ç½‘ç»œå»¶è¿Ÿ
    serverProcessing: number;// æœåŠ¡ç«¯å¤„ç†
  };

  // ===== F5: Prompt ç»“æ„ =====
  prompt: {
    full: string;            // å®Œæ•´ Prompt
    structure: {
      systemInstruction: string;
      chainOfThought: string[];
      fewShotExamples: Array<{
        title: string;
        content: string;
      }>;
      qualityStandards: string[];
      userInput: string;
    };
    metadata: {
      length: number;        // å­—ç¬¦æ•°
      tokenCount: number;    // Token æ•°
      templateVersion: string;
    };
  };

  // ===== F7: è´¨é‡è¯„åˆ† =====
  quality: {
    score: number;           // ç»¼åˆè¯„åˆ† (0-100)
    checks: {
      jsonValid: boolean;
      fieldsComplete: boolean;
      translationAccuracy: 'excellent' | 'good' | 'fair' | 'poor';
      exampleSentenceQuality: 'excellent' | 'good' | 'fair' | 'poor';
      audioTasksGenerated: boolean;
    };
    dimensions: {
      structuralIntegrity: number;  // ç»“æ„å®Œæ•´æ€§ (0-100)
      contentRichness: number;      // å†…å®¹ä¸°å¯Œåº¦ (0-100)
      complianceWithStandards: number; // è§„èŒƒç¬¦åˆåº¦ (0-100)
      audioCompleteness: number;    // éŸ³é¢‘å®Œæ•´æ€§ (0-100)
    };
    warnings: string[];      // è´¨é‡è­¦å‘Š
    suggestions: string[];   // æ”¹è¿›å»ºè®®
  };

  // ===== å…ƒæ•°æ® =====
  metadata: {
    provider: 'gemini' | 'local';
    model: string;
    timestamp: number;
    requestId: string;
  };
}
```

### 3.2 æœåŠ¡å¥åº·çŠ¶æ€ç»“æ„ (HealthStatus)

```typescript
interface HealthStatus {
  // ===== F3: æœåŠ¡çŠ¶æ€ =====
  services: Array<{
    name: string;
    type: 'llm' | 'tts' | 'storage';
    status: 'online' | 'offline' | 'degraded' | 'unknown';
    latency?: number;        // å“åº”æ—¶é—´ (ms)
    message?: string;        // çŠ¶æ€è¯´æ˜
    lastCheck: number;       // æœ€åæ£€æŸ¥æ—¶é—´
    details?: {
      endpoint?: string;
      model?: string;
      quota?: {
        used: number;
        limit: number;
      };
    };
  }>;

  storage: {
    used: number;            // å·²ä½¿ç”¨ (bytes)
    total: number;           // æ€»å®¹é‡ (bytes)
    percentage: number;      // ä½¿ç”¨ç™¾åˆ†æ¯”
    recordsCount: number;    // è®°å½•æ•°é‡
  };

  system: {
    uptime: number;          // è¿è¡Œæ—¶é—´ (ms)
    version: string;         // ç³»ç»Ÿç‰ˆæœ¬
    lastRestart: number;     // æœ€åé‡å¯æ—¶é—´
  };
}
```

### 3.3 å¯¹æ¯”æ¨¡å¼æ•°æ®ç»“æ„ (ComparisonResult)

```typescript
interface ComparisonResult {
  // ===== F9: å¤šæ¨¡å‹å¯¹æ¯” =====
  phrase: string;

  gemini: {
    success: boolean;
    output?: {
      markdown_content: string;
      html_content: string;
      audio_tasks: any[];
    };
    observability: ObservabilityData;
    error?: string;
  };

  local: {
    success: boolean;
    output?: {
      markdown_content: string;
      html_content: string;
      audio_tasks: any[];
    };
    observability: ObservabilityData;
    error?: string;
  };

  comparison: {
    winner: 'gemini' | 'local' | 'tie';
    metrics: {
      speed: { gemini: number; local: number; faster: string };
      quality: { gemini: number; local: number; better: string };
      cost: { gemini: number; local: number; cheaper: string };
    };
    recommendation: string;
  };
}
```

---

## 4. åç«¯è®¾è®¡

### 4.1 æ–°å¢æœåŠ¡æ¨¡å—

#### 4.1.1 å¯è§‚æµ‹æ€§æœåŠ¡ (`services/observabilityService.js`)

```javascript
/**
 * å¯è§‚æµ‹æ€§æœåŠ¡ - ç»Ÿä¸€ç®¡ç† Tokenã€æ€§èƒ½ã€è´¨é‡ç­‰æŒ‡æ ‡
 */

// ===== F1: Token è®¡æ•° =====
class TokenCounter {
  /**
   * è®¡ç®— Token æ•°é‡ï¼ˆç®€å•ä¼°ç®—ï¼Œ1 token â‰ˆ 4 å­—ç¬¦ï¼‰
   */
  static estimate(text) {
    return Math.ceil(text.length / 4);
  }

  /**
   * ä» Gemini API å“åº”æå– Token ä¿¡æ¯
   */
  static extractGeminiTokens(response) {
    const usage = response.usageMetadata;
    return {
      input: usage?.promptTokenCount || 0,
      output: usage?.candidatesTokenCount || 0,
      total: usage?.totalTokenCount || 0,
      cached: usage?.cachedContentTokenCount || 0
    };
  }

  /**
   * ä» OpenAI å…¼å®¹å“åº”æå– Token ä¿¡æ¯
   */
  static extractOpenAITokens(response) {
    const usage = response.usage;
    return {
      input: usage?.prompt_tokens || 0,
      output: usage?.completion_tokens || 0,
      total: usage?.total_tokens || 0
    };
  }

  /**
   * è®¡ç®—æˆæœ¬ï¼ˆåŸºäº Gemini 1.5 Flash å…è´¹å±‚ï¼‰
   */
  static calculateCost(tokens, provider) {
    if (provider === 'gemini') {
      // Gemini 1.5 Flash å…è´¹å±‚ - å®é™…å…è´¹
      return {
        input: 0,
        output: 0,
        total: 0
      };
    }

    if (provider === 'local') {
      return { input: 0, output: 0, total: 0 };
    }

    return { input: 0, output: 0, total: 0 };
  }
}

// ===== F2: æ€§èƒ½ç›‘æ§ =====
class PerformanceMonitor {
  constructor() {
    this.startTime = null;
    this.phases = {};
  }

  start() {
    this.startTime = Date.now();
    return this;
  }

  mark(phaseName) {
    const now = Date.now();
    this.phases[phaseName] = now - (this.lastMark || this.startTime);
    this.lastMark = now;
    return this;
  }

  end() {
    const totalTime = Date.now() - this.startTime;
    return {
      totalTime,
      phases: this.phases,
      networkLatency: this.phases.llmCall || 0,
      serverProcessing: totalTime - (this.phases.llmCall || 0)
    };
  }
}

// ===== F7: è´¨é‡æ£€æŸ¥å™¨ =====
class QualityChecker {
  /**
   * æ£€æŸ¥ç”Ÿæˆå†…å®¹è´¨é‡
   */
  static check(content, expectedPhrase) {
    const checks = {
      jsonValid: this.isValidJSON(content),
      fieldsComplete: this.hasRequiredFields(content),
      translationAccuracy: this.checkTranslation(content, expectedPhrase),
      exampleSentenceQuality: this.checkExampleQuality(content),
      audioTasksGenerated: this.hasAudioTasks(content)
    };

    const dimensions = {
      structuralIntegrity: this.calculateStructuralScore(checks),
      contentRichness: this.calculateRichnessScore(content),
      complianceWithStandards: this.calculateComplianceScore(content),
      audioCompleteness: this.calculateAudioScore(content)
    };

    const score = this.calculateOverallScore(dimensions);

    const warnings = this.generateWarnings(checks, dimensions);
    const suggestions = this.generateSuggestions(warnings);

    return { score, checks, dimensions, warnings, suggestions };
  }

  static isValidJSON(content) {
    return typeof content === 'object' && content !== null;
  }

  static hasRequiredFields(content) {
    const required = ['markdown_content', 'html_content'];
    return required.every(field =>
      typeof content[field] === 'string' && content[field].trim()
    );
  }

  static checkTranslation(content, phrase) {
    // ç®€å•æ£€æŸ¥ï¼šmarkdown å†…å®¹æ˜¯å¦åŒ…å«åŸçŸ­è¯­
    const markdown = content.markdown_content || '';
    const hasPhrase = markdown.toLowerCase().includes(phrase.toLowerCase());
    return hasPhrase ? 'good' : 'fair';
  }

  static checkExampleQuality(content) {
    // æ£€æŸ¥ä¾‹å¥æ•°é‡å’Œé•¿åº¦
    const markdown = content.markdown_content || '';
    const sentences = markdown.match(/\d+\.\s+.+/g) || [];

    if (sentences.length >= 3) {
      const avgLength = sentences.reduce((sum, s) =>
        sum + s.split(' ').length, 0) / sentences.length;

      if (avgLength >= 8 && avgLength <= 20) return 'excellent';
      if (avgLength >= 5 && avgLength <= 25) return 'good';
      return 'fair';
    }

    return 'poor';
  }

  static hasAudioTasks(content) {
    return Array.isArray(content.audio_tasks) && content.audio_tasks.length > 0;
  }

  static calculateStructuralScore(checks) {
    const weights = { jsonValid: 40, fieldsComplete: 60 };
    let score = 0;
    if (checks.jsonValid) score += weights.jsonValid;
    if (checks.fieldsComplete) score += weights.fieldsComplete;
    return score;
  }

  static calculateRichnessScore(content) {
    const markdown = content.markdown_content || '';
    const hasMultipleSections = (markdown.match(/##/g) || []).length >= 3;
    const hasExamples = (markdown.match(/\d+\.\s+/g) || []).length >= 3;
    const hasRuby = markdown.includes('(') && markdown.includes(')');

    let score = 0;
    if (hasMultipleSections) score += 40;
    if (hasExamples) score += 40;
    if (hasRuby) score += 20;
    return score;
  }

  static calculateComplianceScore(content) {
    const quality = this.checkExampleQuality(content);
    const qualityMap = {
      excellent: 100,
      good: 80,
      fair: 60,
      poor: 40
    };
    return qualityMap[quality] || 50;
  }

  static calculateAudioScore(content) {
    return this.hasAudioTasks(content) ? 100 : 0;
  }

  static calculateOverallScore(dimensions) {
    const weights = {
      structuralIntegrity: 0.3,
      contentRichness: 0.3,
      complianceWithStandards: 0.3,
      audioCompleteness: 0.1
    };

    return Math.round(
      dimensions.structuralIntegrity * weights.structuralIntegrity +
      dimensions.contentRichness * weights.contentRichness +
      dimensions.complianceWithStandards * weights.complianceWithStandards +
      dimensions.audioCompleteness * weights.audioCompleteness
    );
  }

  static generateWarnings(checks, dimensions) {
    const warnings = [];

    if (!checks.jsonValid) warnings.push('JSON æ ¼å¼æ— æ•ˆ');
    if (!checks.fieldsComplete) warnings.push('ç¼ºå°‘å¿…éœ€å­—æ®µ');
    if (checks.translationAccuracy === 'poor') warnings.push('ç¿»è¯‘å‡†ç¡®æ€§è¾ƒä½');
    if (checks.exampleSentenceQuality === 'poor') warnings.push('ä¾‹å¥è´¨é‡ä¸ä½³');
    if (!checks.audioTasksGenerated) warnings.push('æœªç”ŸæˆéŸ³é¢‘ä»»åŠ¡');
    if (dimensions.contentRichness < 60) warnings.push('å†…å®¹ä¸°å¯Œåº¦åä½');

    return warnings;
  }

  static generateSuggestions(warnings) {
    const suggestions = [];

    warnings.forEach(warning => {
      if (warning.includes('JSON')) {
        suggestions.push('æ£€æŸ¥ LLM è¾“å‡ºæ ¼å¼ï¼Œç¡®ä¿è¿”å›æœ‰æ•ˆ JSON');
      }
      if (warning.includes('ä¾‹å¥')) {
        suggestions.push('è°ƒæ•´ Prompt ä¸­çš„ä¾‹å¥è´¨é‡æ ‡å‡†');
      }
      if (warning.includes('éŸ³é¢‘')) {
        suggestions.push('ç¡®è®¤ audio_tasks å­—æ®µç”Ÿæˆé€»è¾‘');
      }
    });

    return suggestions;
  }
}

// ===== F5: Prompt ç»“æ„åŒ–è§£æ =====
class PromptParser {
  /**
   * è§£æ Prompt ç»“æ„
   */
  static parse(fullPrompt) {
    // åŸºäº promptEngine.js çš„ç»“æ„è¿›è¡Œè§£æ
    const sections = {
      systemInstruction: '',
      chainOfThought: [],
      fewShotExamples: [],
      qualityStandards: [],
      userInput: ''
    };

    // System Instruction
    const sysMatch = fullPrompt.match(/ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä¸‰è¯­.*?è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤/s);
    if (sysMatch) sections.systemInstruction = sysMatch[0];

    // Chain of Thought
    const cotMatches = fullPrompt.match(/æ­¥éª¤ \d+ï¼š.*?(?=æ­¥éª¤ \d+ï¼š|## ç¤ºä¾‹|$)/gs);
    if (cotMatches) sections.chainOfThought = cotMatches.map(s => s.trim());

    // Few-shot Examples
    const exampleMatches = fullPrompt.match(/### ç¤ºä¾‹ \d+ï¼š.*?(?=### ç¤ºä¾‹ \d+ï¼š|## è´¨é‡æ ‡å‡†|$)/gs);
    if (exampleMatches) {
      sections.fewShotExamples = exampleMatches.map(ex => {
        const titleMatch = ex.match(/### ç¤ºä¾‹ \d+ï¼š(.+)/);
        return {
          title: titleMatch ? titleMatch[1] : '',
          content: ex
        };
      });
    }

    // Quality Standards
    const qualityMatch = fullPrompt.match(/## è´¨é‡æ ‡å‡†.*?(?=---|\n\nç”¨æˆ·è¾“å…¥|$)/s);
    if (qualityMatch) {
      const standards = qualityMatch[0].match(/- \*\*(.+?)\*\*/g) || [];
      sections.qualityStandards = standards.map(s => s.replace(/- \*\*|\*\*/g, ''));
    }

    // User Input
    const inputMatch = fullPrompt.match(/ç”¨æˆ·è¾“å…¥çš„çŸ­è¯­æˆ–å¥å­ï¼š(.+)/);
    if (inputMatch) sections.userInput = inputMatch[1].trim();

    return {
      full: fullPrompt,
      structure: sections,
      metadata: {
        length: fullPrompt.length,
        tokenCount: TokenCounter.estimate(fullPrompt),
        templateVersion: 'v2.0-optimized'
      }
    };
  }
}

module.exports = {
  TokenCounter,
  PerformanceMonitor,
  QualityChecker,
  PromptParser
};
```

#### 4.1.2 å¥åº·æ£€æŸ¥æœåŠ¡ (`services/healthCheckService.js`)

```javascript
/**
 * å¥åº·æ£€æŸ¥æœåŠ¡ - F3: æœåŠ¡çŠ¶æ€ç›‘æ§
 */

require('dotenv').config();
const fs = require('fs');
const path = require('path');

class HealthCheckService {
  /**
   * æ£€æŸ¥æ‰€æœ‰æœåŠ¡å¥åº·çŠ¶æ€
   */
  static async checkAll() {
    const services = [];

    // 1. Gemini API
    if (process.env.GEMINI_API_KEY) {
      services.push(await this.checkGemini());
    }

    // 2. Local LLM
    if (process.env.LLM_BASE_URL) {
      services.push(await this.checkLocalLLM());
    }

    // 3. TTS Services
    if (process.env.TTS_EN_ENDPOINT) {
      services.push(await this.checkTTSEnglish());
    }
    if (process.env.TTS_JA_ENDPOINT) {
      services.push(await this.checkTTSJapanese());
    }

    // 4. Storage
    services.push(await this.checkStorage());

    const system = {
      uptime: process.uptime() * 1000,
      version: process.env.npm_package_version || '1.0.0',
      lastRestart: Date.now() - process.uptime() * 1000
    };

    return { services, system };
  }

  /**
   * æ£€æŸ¥ Gemini API
   */
  static async checkGemini() {
    const service = {
      name: 'Gemini API',
      type: 'llm',
      status: 'unknown',
      lastCheck: Date.now(),
      details: {
        endpoint: process.env.GEMINI_BASE_URL,
        model: process.env.GEMINI_MODEL
      }
    };

    try {
      const startTime = Date.now();

      // ç®€å•çš„ API è°ƒç”¨æµ‹è¯•
      const url = `${process.env.GEMINI_BASE_URL}/models/${process.env.GEMINI_MODEL}?key=${process.env.GEMINI_API_KEY}`;
      const response = await fetch(url, {
        method: 'GET',
        signal: AbortSignal.timeout(5000)
      });

      service.latency = Date.now() - startTime;

      if (response.ok) {
        service.status = 'online';
        service.message = 'API æ­£å¸¸';

        // å°è¯•è·å–é…é¢ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        // æ³¨æ„ï¼šGemini API å¯èƒ½ä¸ç›´æ¥æš´éœ²é…é¢ï¼Œéœ€è¦ä»å“åº”å¤´æˆ–å…¶ä»–æ–¹å¼è·å–
        service.details.quota = {
          used: 0,  // éœ€è¦ä»å®é™…ä½¿ç”¨è®°å½•è®¡ç®—
          limit: 1500
        };
      } else {
        service.status = 'degraded';
        service.message = `API å“åº”å¼‚å¸¸: ${response.status}`;
      }
    } catch (error) {
      service.status = 'offline';
      service.message = error.message;
    }

    return service;
  }

  /**
   * æ£€æŸ¥æœ¬åœ° LLM
   */
  static async checkLocalLLM() {
    const service = {
      name: 'Local LLM',
      type: 'llm',
      status: 'unknown',
      lastCheck: Date.now(),
      details: {
        endpoint: process.env.LLM_BASE_URL,
        model: process.env.LLM_MODEL
      }
    };

    try {
      const startTime = Date.now();
      const url = `${process.env.LLM_BASE_URL}/models`;

      const response = await fetch(url, {
        method: 'GET',
        signal: AbortSignal.timeout(5000)
      });

      service.latency = Date.now() - startTime;

      if (response.ok) {
        service.status = 'online';
        service.message = 'æœ¬åœ°æ¨¡å‹æ­£å¸¸';
      } else {
        service.status = 'degraded';
        service.message = 'è¿æ¥å¼‚å¸¸';
      }
    } catch (error) {
      service.status = 'offline';
      service.message = 'æœªé…ç½®æˆ–æ— æ³•è¿æ¥';
    }

    return service;
  }

  /**
   * æ£€æŸ¥è‹±æ–‡ TTS
   */
  static async checkTTSEnglish() {
    const service = {
      name: 'TTS English (Kokoro)',
      type: 'tts',
      status: 'unknown',
      lastCheck: Date.now(),
      details: {
        endpoint: process.env.TTS_EN_ENDPOINT
      }
    };

    try {
      const startTime = Date.now();
      // ç®€å•çš„ health check
      const baseUrl = process.env.TTS_EN_ENDPOINT.replace('/v1/audio/speech', '');
      const response = await fetch(`${baseUrl}/health`, {
        method: 'GET',
        signal: AbortSignal.timeout(3000)
      }).catch(() => ({ ok: true })); // å¦‚æœæ²¡æœ‰ health ç«¯ç‚¹ï¼Œå‡è®¾åœ¨çº¿

      service.latency = Date.now() - startTime;
      service.status = 'online';
      service.message = 'æœåŠ¡æ­£å¸¸';
    } catch (error) {
      service.status = 'offline';
      service.message = error.message;
    }

    return service;
  }

  /**
   * æ£€æŸ¥æ—¥æ–‡ TTS
   */
  static async checkTTSJapanese() {
    const service = {
      name: 'TTS Japanese (VOICEVOX)',
      type: 'tts',
      status: 'unknown',
      lastCheck: Date.now(),
      details: {
        endpoint: process.env.TTS_JA_ENDPOINT
      }
    };

    try {
      const startTime = Date.now();
      const response = await fetch(`${process.env.TTS_JA_ENDPOINT}/version`, {
        method: 'GET',
        signal: AbortSignal.timeout(3000)
      });

      service.latency = Date.now() - startTime;

      if (response.ok) {
        service.status = service.latency > 2000 ? 'degraded' : 'online';
        service.message = service.latency > 2000 ? 'å“åº”ç¼“æ…¢' : 'æœåŠ¡æ­£å¸¸';
      } else {
        service.status = 'degraded';
        service.message = 'è¿æ¥å¼‚å¸¸';
      }
    } catch (error) {
      service.status = 'offline';
      service.message = error.message;
    }

    return service;
  }

  /**
   * æ£€æŸ¥å­˜å‚¨
   */
  static async checkStorage() {
    const service = {
      name: 'Storage',
      type: 'storage',
      status: 'unknown',
      lastCheck: Date.now()
    };

    try {
      const recordsPath = process.env.RECORDS_PATH || '/data/trilingual_records';

      if (!fs.existsSync(recordsPath)) {
        service.status = 'offline';
        service.message = 'å­˜å‚¨è·¯å¾„ä¸å­˜åœ¨';
        return service;
      }

      // è®¡ç®—å·²ä½¿ç”¨ç©ºé—´
      const getDirectorySize = (dir) => {
        let size = 0;
        const files = fs.readdirSync(dir, { withFileTypes: true });

        for (const file of files) {
          const filePath = path.join(dir, file.name);
          if (file.isDirectory()) {
            size += getDirectorySize(filePath);
          } else {
            const stats = fs.statSync(filePath);
            size += stats.size;
          }
        }

        return size;
      };

      const used = getDirectorySize(recordsPath);
      const total = 6 * 1024 * 1024 * 1024; // å‡è®¾ 6GB æ€»å®¹é‡
      const percentage = (used / total) * 100;

      // ç»Ÿè®¡è®°å½•æ•°
      const folders = fs.readdirSync(recordsPath, { withFileTypes: true })
        .filter(entry => entry.isDirectory());

      let recordsCount = 0;
      folders.forEach(folder => {
        const folderPath = path.join(recordsPath, folder.name);
        const htmlFiles = fs.readdirSync(folderPath)
          .filter(file => file.endsWith('.html'));
        recordsCount += htmlFiles.length;
      });

      service.status = percentage > 90 ? 'degraded' : 'online';
      service.message = percentage > 90 ? 'å­˜å‚¨ç©ºé—´ä¸è¶³' : 'å­˜å‚¨æ­£å¸¸';
      service.details = {
        used,
        total,
        percentage: Math.round(percentage * 100) / 100,
        recordsCount
      };
    } catch (error) {
      service.status = 'offline';
      service.message = error.message;
    }

    return service;
  }
}

module.exports = { HealthCheckService };
```

### 4.2 API è·¯ç”±ä¿®æ”¹

#### 4.2.1 å¢å¼º `/api/generate` ç«¯ç‚¹

```javascript
// server.js ä¿®æ”¹

const { TokenCounter, PerformanceMonitor, QualityChecker, PromptParser } = require('./services/observabilityService');

app.post('/api/generate', async (req, res) => {
  let prompt = null;
  const perf = new PerformanceMonitor().start();

  try {
    if (!canGenerate(req)) {
      return res.status(429).json({ error: 'ç”Ÿæˆè¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•' });
    }

    // ===== F9: å¯¹æ¯”æ¨¡å¼æ”¯æŒ =====
    const { phrase, llm_provider = 'gemini', enable_compare = false } = req.body;

    if (!phrase) {
      return res.status(400).json({ error: 'Phrase is required' });
    }

    // å¯¹æ¯”æ¨¡å¼ï¼šåŒæ—¶è°ƒç”¨ä¸¤ä¸ª provider
    if (enable_compare) {
      return await handleComparisonMode(req, res, phrase);
    }

    // ===== å•æ¨¡å‹æ¨¡å¼ =====
    const llmService = llm_provider === 'local' ? localLlmService : geminiService;

    console.log(`[Generate] Using provider: ${llm_provider.toUpperCase()}`);
    console.log(`[Generate] Phrase: "${phrase}"`);

    // 1. Build Prompt
    perf.mark('promptBuild');
    const { targetDir, folderName } = ensureTodayDirectory();
    const baseName = buildBaseName(phrase, targetDir);
    prompt = buildPrompt({ phrase, filenameBase: baseName });

    // 2. Call LLM
    perf.mark('llmCall');
    const content = await llmService.generateContent(prompt);
    const llmOutput = JSON.parse(JSON.stringify(content));

    perf.mark('jsonParse');

    // éªŒè¯å†…å®¹
    const renderHtmlLocally = (process.env.HTML_RENDER_MODE || 'local').toLowerCase() === 'local';
    const validationErrors = validateGeneratedContent(content, {
      allowMissingHtml: renderHtmlLocally,
      allowMissingAudioTasks: renderHtmlLocally,
    });

    if (validationErrors.length) {
      return res.status(422).json({
        error: `Invalid AI response: ${validationErrors.join('; ')}`,
        details: validationErrors,
        prompt,
        llm_output: llmOutput,
      });
    }

    // éŸ³é¢‘ä»»åŠ¡å¤„ç†
    const derivedAudioTasks = buildAudioTasksFromMarkdown(content.markdown_content);
    if (!Array.isArray(content.audio_tasks) || !content.audio_tasks.length) {
      content.audio_tasks = derivedAudioTasks;
    }

    const preparedMarkdown = await prepareMarkdownForCard(content.markdown_content, {
      baseName,
      audioTasks: content.audio_tasks,
    });
    content.markdown_content = preparedMarkdown;

    if (renderHtmlLocally || !content.html_content) {
      content.html_content = await renderHtmlFromMarkdown(preparedMarkdown, {
        baseName,
        audioTasks: content.audio_tasks,
        prepared: true,
      });
    }

    // 3. Save Files
    perf.mark('fileSave');
    const result = saveGeneratedFiles(phrase, content, { baseName, targetDir, folderName });

    console.log(`[Generate] Success. Saved to ${result.folder}/${result.files.join(', ')}`);

    // 4. TTS
    let audio = null;
    const hasTtsEndpoint = process.env.TTS_API_ENDPOINT || process.env.TTS_EN_ENDPOINT || process.env.TTS_JA_ENDPOINT;

    if (hasTtsEndpoint && Array.isArray(content.audio_tasks) && content.audio_tasks.length) {
      const audioTasks = normalizeAudioTasks(content.audio_tasks, result.baseName);
      audio = await generateAudioBatch(audioTasks, {
        outputDir: result.targetDir,
        baseName: result.baseName,
        extension: 'wav',
      });

      if (audio.errors && audio.errors.length) {
        console.warn('[Generate] TTS errors:', audio.errors);
      }
    }

    perf.mark('audioGenerate');
    const performance = perf.end();

    // ===== æ„å»ºå¯è§‚æµ‹æ€§æ•°æ® =====

    // F1: Token è®¡æ•°
    const tokens = llm_provider === 'gemini'
      ? TokenCounter.extractGeminiTokens(llmOutput)  // éœ€è¦ä» API åŸå§‹å“åº”æå–
      : TokenCounter.extractOpenAITokens(llmOutput);

    const cost = TokenCounter.calculateCost(tokens, llm_provider);

    // å‡è®¾é…é¢æ•°æ®ï¼ˆå®é™…åº”ä»æ•°æ®åº“æˆ–ç¼“å­˜è¯»å–ï¼‰
    const quota = {
      used: 180,  // éœ€è¦æŒä¹…åŒ–ç»Ÿè®¡
      limit: 1500,
      remaining: 1320,
      resetAt: new Date().setHours(24, 0, 0, 0),
      percentage: (180 / 1500) * 100
    };

    // F5: Prompt è§£æ
    const promptData = PromptParser.parse(prompt);

    // F7: è´¨é‡æ£€æŸ¥
    const quality = QualityChecker.check(content, phrase);

    // ç»„è£…å¯è§‚æµ‹æ€§æ•°æ®
    const observability = {
      tokens,
      cost,
      quota,
      performance,
      prompt: promptData,
      quality,
      metadata: {
        provider: llm_provider,
        model: process.env[llm_provider === 'gemini' ? 'GEMINI_MODEL' : 'LLM_MODEL'],
        timestamp: Date.now(),
        requestId: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      }
    };

    res.json({
      success: true,
      result,
      audio,
      prompt,
      llm_output: llmOutput,
      observability  // âœ… æ–°å¢å¯è§‚æµ‹æ€§æ•°æ®
    });

  } catch (error) {
    console.error('[Generate] Error:', error);
    res.status(500).json({ error: error.message || 'Generation failed', prompt });
  }
});

/**
 * F9: å¤„ç†å¯¹æ¯”æ¨¡å¼
 */
async function handleComparisonMode(req, res, phrase) {
  console.log('[Comparison] Starting parallel generation...');

  const results = {
    phrase,
    gemini: { success: false },
    local: { success: false },
    comparison: null
  };

  // å¹¶è¡Œè°ƒç”¨ä¸¤ä¸ª provider
  const [geminiResult, localResult] = await Promise.allSettled([
    generateWithProvider(phrase, 'gemini'),
    generateWithProvider(phrase, 'local')
  ]);

  // å¤„ç† Gemini ç»“æœ
  if (geminiResult.status === 'fulfilled') {
    results.gemini = {
      success: true,
      output: geminiResult.value.output,
      observability: geminiResult.value.observability
    };
  } else {
    results.gemini = {
      success: false,
      error: geminiResult.reason.message
    };
  }

  // å¤„ç† Local ç»“æœ
  if (localResult.status === 'fulfilled') {
    results.local = {
      success: true,
      output: localResult.value.output,
      observability: localResult.value.observability
    };
  } else {
    results.local = {
      success: false,
      error: localResult.reason.message
    };
  }

  // ç”Ÿæˆå¯¹æ¯”åˆ†æ
  if (results.gemini.success && results.local.success) {
    results.comparison = {
      metrics: {
        speed: {
          gemini: results.gemini.observability.performance.totalTime,
          local: results.local.observability.performance.totalTime,
          faster: results.gemini.observability.performance.totalTime <
                  results.local.observability.performance.totalTime ? 'gemini' : 'local'
        },
        quality: {
          gemini: results.gemini.observability.quality.score,
          local: results.local.observability.quality.score,
          better: results.gemini.observability.quality.score >
                  results.local.observability.quality.score ? 'gemini' : 'local'
        },
        cost: {
          gemini: results.gemini.observability.cost.total,
          local: results.local.observability.cost.total,
          cheaper: results.gemini.observability.cost.total <
                   results.local.observability.cost.total ? 'gemini' : 'local'
        }
      },
      winner: determineWinner(results.gemini.observability, results.local.observability),
      recommendation: generateRecommendation(results.gemini.observability, results.local.observability)
    };
  }

  res.json(results);
}

/**
 * ä½¿ç”¨æŒ‡å®š provider ç”Ÿæˆ
 */
async function generateWithProvider(phrase, provider) {
  const perf = new PerformanceMonitor().start();
  const llmService = provider === 'local' ? localLlmService : geminiService;

  perf.mark('promptBuild');
  const { targetDir, folderName } = ensureTodayDirectory();
  const baseName = buildBaseName(phrase, targetDir);
  const prompt = buildPrompt({ phrase, filenameBase: baseName });

  perf.mark('llmCall');
  const content = await llmService.generateContent(prompt);

  perf.mark('jsonParse');
  const performance = perf.end();

  const tokens = provider === 'gemini'
    ? TokenCounter.extractGeminiTokens(content)
    : TokenCounter.extractOpenAITokens(content);

  const quality = QualityChecker.check(content, phrase);

  return {
    output: content,
    observability: {
      tokens,
      cost: TokenCounter.calculateCost(tokens, provider),
      performance,
      quality,
      metadata: { provider, timestamp: Date.now() }
    }
  };
}

function determineWinner(geminiObs, localObs) {
  const geminiScore = geminiObs.quality.score * 0.6 +
                      (10000 / geminiObs.performance.totalTime) * 0.4;
  const localScore = localObs.quality.score * 0.6 +
                     (10000 / localObs.performance.totalTime) * 0.4;

  if (Math.abs(geminiScore - localScore) < 5) return 'tie';
  return geminiScore > localScore ? 'gemini' : 'local';
}

function generateRecommendation(geminiObs, localObs) {
  const speedDiff = localObs.performance.totalTime - geminiObs.performance.totalTime;
  const qualityDiff = geminiObs.quality.score - localObs.quality.score;

  if (qualityDiff > 10 && speedDiff < 2000) {
    return 'æ¨èä½¿ç”¨ Geminiï¼šè´¨é‡æ›´é«˜ä¸”é€Ÿåº¦ç›¸å½“';
  }
  if (speedDiff > 3000 && qualityDiff < 5) {
    return 'æ¨èä½¿ç”¨ Geminiï¼šé€Ÿåº¦æ˜æ˜¾æ›´å¿«';
  }
  if (localObs.cost.total === 0 && qualityDiff < 10) {
    return 'æ¨èä½¿ç”¨ Local LLMï¼šæˆæœ¬ä¸ºé›¶ä¸”è´¨é‡æ¥è¿‘';
  }

  return 'ä¸¤è€…è¡¨ç°ç›¸å½“ï¼Œå¯æ ¹æ®å®é™…éœ€æ±‚é€‰æ‹©';
}
```

#### 4.2.2 æ–°å¢ `/api/health` ç«¯ç‚¹

```javascript
// server.js æ·»åŠ 

const { HealthCheckService } = require('./services/healthCheckService');

/**
 * F3: å¥åº·æ£€æŸ¥ç«¯ç‚¹
 */
app.get('/api/health', async (req, res) => {
  try {
    const { services, system } = await HealthCheckService.checkAll();

    // è®¡ç®—å­˜å‚¨ä¿¡æ¯
    const storageService = services.find(s => s.type === 'storage');
    const storage = storageService?.details || {
      used: 0,
      total: 0,
      percentage: 0,
      recordsCount: 0
    };

    res.json({
      services,
      storage,
      system
    });
  } catch (error) {
    console.error('[Health] Error:', error);
    res.status(500).json({ error: 'Health check failed' });
  }
});
```

---

## 5. å‰ç«¯è®¾è®¡

### 5.1 UI ç»„ä»¶ç»“æ„

```
public/
â”œâ”€â”€ index.html          # æ–°å¢å¯è§‚æµ‹æ€§é¢æ¿
â”œâ”€â”€ main.js             # æ–°å¢å¯è§‚æµ‹æ€§é€»è¾‘
â”œâ”€â”€ styles.css          # åŸºç¡€æ ·å¼
â”œâ”€â”€ observability.css   # æ–°å¢ï¼šå¯è§‚æµ‹æ€§æ ·å¼
â””â”€â”€ components/
    â”œâ”€â”€ TokenStats.js        # F1: Token ç»Ÿè®¡ç»„ä»¶
    â”œâ”€â”€ PerformancePanel.js  # F2: æ€§èƒ½é¢æ¿
    â”œâ”€â”€ HealthStatus.js      # F3: å¥åº·çŠ¶æ€
    â”œâ”€â”€ PromptInspector.js   # F5: Prompt æ£€æŸ¥å™¨
    â”œâ”€â”€ QualityScore.js      # F7: è´¨é‡è¯„åˆ†
    â””â”€â”€ ComparisonView.js    # F9: å¯¹æ¯”è§†å›¾
```

### 5.2 HTML ç»“æ„ä¿®æ”¹

```html
<!-- public/index.html åœ¨ç”Ÿæˆé¢æ¿ä¸‹æ–¹æ·»åŠ  -->

<!-- ========== å¯è§‚æµ‹æ€§é¢æ¿ ========== -->
<div id="observabilityPanel" class="observability-panel hidden">

  <!-- F1: Token ç»Ÿè®¡ -->
  <div class="obs-section token-stats">
    <h4 class="obs-title">ğŸ“Š Token ä½¿ç”¨æƒ…å†µ</h4>
    <div class="token-grid">
      <div class="token-item">
        <span class="token-label">Input</span>
        <span class="token-value" id="tokenInput">-</span>
      </div>
      <div class="token-item">
        <span class="token-label">Output</span>
        <span class="token-value" id="tokenOutput">-</span>
      </div>
      <div class="token-item">
        <span class="token-label">Total</span>
        <span class="token-value" id="tokenTotal">-</span>
      </div>
      <div class="token-item">
        <span class="token-label">Cost</span>
        <span class="token-value" id="tokenCost">$0.000</span>
      </div>
    </div>
    <div class="quota-bar">
      <div class="quota-label">
        <span>ä»Šæ—¥é…é¢</span>
        <span id="quotaText">0/1,500</span>
      </div>
      <div class="quota-progress">
        <div class="quota-fill" id="quotaFill" style="width: 0%"></div>
      </div>
    </div>
  </div>

  <!-- F2: æ€§èƒ½æŒ‡æ ‡ -->
  <div class="obs-section performance-metrics">
    <h4 class="obs-title">âš¡ æ€§èƒ½åˆ†æ</h4>
    <div class="perf-summary">
      <div class="perf-total">
        <span class="perf-value" id="perfTotal">-</span>
        <span class="perf-label">æ€»è€—æ—¶</span>
      </div>
    </div>
    <div class="perf-breakdown">
      <div class="perf-phase">
        <span class="phase-name">Prompt æ„å»º</span>
        <div class="phase-bar-container">
          <div class="phase-bar" id="perfPromptBar" style="width: 0%"></div>
        </div>
        <span class="phase-time" id="perfPromptTime">-</span>
      </div>
      <div class="perf-phase">
        <span class="phase-name">LLM è°ƒç”¨</span>
        <div class="phase-bar-container">
          <div class="phase-bar" id="perfLlmBar" style="width: 0%"></div>
        </div>
        <span class="phase-time" id="perfLlmTime">-</span>
      </div>
      <div class="perf-phase">
        <span class="phase-name">JSON è§£æ</span>
        <div class="phase-bar-container">
          <div class="phase-bar" id="perfParseBar" style="width: 0%"></div>
        </div>
        <span class="phase-time" id="perfParseTime">-</span>
      </div>
      <div class="perf-phase">
        <span class="phase-name">æ–‡ä»¶ä¿å­˜</span>
        <div class="phase-bar-container">
          <div class="phase-bar" id="perfSaveBar" style="width: 0%"></div>
        </div>
        <span class="phase-time" id="perfSaveTime">-</span>
      </div>
    </div>
  </div>

  <!-- F7: è´¨é‡è¯„åˆ† -->
  <div class="obs-section quality-score">
    <h4 class="obs-title">âœ¨ å†…å®¹è´¨é‡</h4>
    <div class="quality-main">
      <div class="quality-circle">
        <svg viewBox="0 0 100 100">
          <circle cx="50" cy="50" r="40" class="quality-bg"></circle>
          <circle cx="50" cy="50" r="40" class="quality-progress"
                  id="qualityCircle"
                  style="stroke-dasharray: 251; stroke-dashoffset: 251"></circle>
        </svg>
        <div class="quality-score-value" id="qualityScore">-</div>
      </div>
      <div class="quality-checks" id="qualityChecks">
        <!-- åŠ¨æ€ç”Ÿæˆè´¨é‡æ£€æŸ¥é¡¹ -->
      </div>
    </div>
    <div class="quality-warnings" id="qualityWarnings"></div>
  </div>

  <!-- F5: Prompt ç»“æ„ -->
  <div class="obs-section prompt-structure">
    <h4 class="obs-title">ğŸ“‹ Prompt ç»“æ„</h4>
    <div class="prompt-tabs">
      <button class="prompt-tab active" data-tab="full">å®Œæ•´ Prompt</button>
      <button class="prompt-tab" data-tab="structure">ç»“æ„åŒ–è§†å›¾</button>
    </div>
    <div class="prompt-tab-content">
      <div class="prompt-tab-panel active" id="promptFull">
        <pre id="promptFullContent"></pre>
      </div>
      <div class="prompt-tab-panel" id="promptStructure">
        <div class="prompt-section">
          <h5>ğŸ¯ System Instruction</h5>
          <pre id="promptSystem"></pre>
        </div>
        <div class="prompt-section">
          <h5>ğŸ§  Chain of Thought</h5>
          <ol id="promptCoT"></ol>
        </div>
        <div class="prompt-section">
          <h5>ğŸ“š Few-shot Examples</h5>
          <div id="promptExamples"></div>
        </div>
        <div class="prompt-section">
          <h5>âœ… Quality Standards</h5>
          <ul id="promptStandards"></ul>
        </div>
        <div class="prompt-section">
          <h5>ğŸ“ User Input</h5>
          <pre id="promptUserInput"></pre>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- F3: å¥åº·çŠ¶æ€é¢æ¿ï¼ˆå³ä¾§è¾¹æ ï¼‰ -->
<div id="healthPanel" class="health-panel">
  <button id="healthToggle" class="health-toggle">
    <span class="health-icon">ğŸ¥</span>
    <span class="health-text">ç³»ç»ŸçŠ¶æ€</span>
  </button>
  <div class="health-content hidden">
    <h4>æœåŠ¡å¥åº·çŠ¶æ€</h4>
    <div id="healthServices" class="health-services">
      <!-- åŠ¨æ€ç”ŸæˆæœåŠ¡çŠ¶æ€ -->
    </div>
    <div class="health-storage">
      <h5>å­˜å‚¨ç©ºé—´</h5>
      <div class="storage-bar">
        <div class="storage-fill" id="storageFill" style="width: 0%"></div>
      </div>
      <span class="storage-text" id="storageText">-</span>
    </div>
    <button id="healthRefresh" class="btn-secondary">åˆ·æ–°çŠ¶æ€</button>
  </div>
</div>

<!-- F9: å¯¹æ¯”æ¨¡å¼åˆ‡æ¢ -->
<div class="comparison-controls">
  <label class="comparison-toggle">
    <input type="checkbox" id="enableCompare" />
    <span>å¯ç”¨å¯¹æ¯”æ¨¡å¼</span>
  </label>
</div>

<!-- F9: å¯¹æ¯”ç»“æœæ˜¾ç¤ºï¼ˆæ¨¡æ€æ¡†ï¼‰ -->
<div id="comparisonModal" class="modal hidden">
  <div class="modal-content comparison-view">
    <button class="modal-close" onclick="closeComparisonModal()">Ã—</button>
    <h2>ğŸ” æ¨¡å‹å¯¹æ¯”åˆ†æ</h2>

    <div class="comparison-grid">
      <div class="comparison-panel">
        <div class="comparison-header gemini">
          <h3>ğŸ¤– Gemini API</h3>
          <span class="comparison-status" id="geminiStatus"></span>
        </div>
        <div class="comparison-metrics" id="geminiMetrics"></div>
        <div class="comparison-output" id="geminiOutput"></div>
      </div>

      <div class="comparison-panel">
        <div class="comparison-header local">
          <h3>ğŸ–¥ï¸ Local LLM</h3>
          <span class="comparison-status" id="localStatus"></span>
        </div>
        <div class="comparison-metrics" id="localMetrics"></div>
        <div class="comparison-output" id="localOutput"></div>
      </div>
    </div>

    <div class="comparison-summary">
      <h3>ğŸ“Š å¯¹æ¯”æ€»ç»“</h3>
      <div class="comparison-winner" id="comparisonWinner"></div>
      <div class="comparison-recommendation" id="comparisonRec"></div>
    </div>
  </div>
</div>
```

### 5.3 JavaScript é€»è¾‘

```javascript
// public/main.js æ·»åŠ 

// ========== å¯è§‚æµ‹æ€§ç›¸å…³å˜é‡ ==========
const observabilityPanel = document.getElementById('observabilityPanel');
const enableCompareCheckbox = document.getElementById('enableCompare');

// ========== F1: æ›´æ–° Token ç»Ÿè®¡ ==========
function updateTokenStats(observability) {
  if (!observability || !observability.tokens) return;

  const { tokens, cost, quota } = observability;

  document.getElementById('tokenInput').textContent = tokens.input.toLocaleString();
  document.getElementById('tokenOutput').textContent = tokens.output.toLocaleString();
  document.getElementById('tokenTotal').textContent = tokens.total.toLocaleString();
  document.getElementById('tokenCost').textContent = `$${cost.total.toFixed(4)}`;

  if (quota) {
    document.getElementById('quotaText').textContent = `${quota.used}/${quota.limit}`;
    document.getElementById('quotaFill').style.width = `${quota.percentage}%`;

    // é…é¢é¢„è­¦
    if (quota.percentage > 80) {
      document.getElementById('quotaFill').classList.add('warning');
    }
  }
}

// ========== F2: æ›´æ–°æ€§èƒ½æŒ‡æ ‡ ==========
function updatePerformanceMetrics(observability) {
  if (!observability || !observability.performance) return;

  const { performance } = observability;
  const { totalTime, phases } = performance;

  document.getElementById('perfTotal').textContent = `${(totalTime / 1000).toFixed(2)}s`;

  // æ›´æ–°å„é˜¶æ®µ
  const phaseData = [
    { id: 'perfPrompt', time: phases.promptBuild || 0 },
    { id: 'perfLlm', time: phases.llmCall || 0 },
    { id: 'perfParse', time: phases.jsonParse || 0 },
    { id: 'perfSave', time: phases.fileSave || 0 }
  ];

  phaseData.forEach(({ id, time }) => {
    const percentage = (time / totalTime) * 100;
    document.getElementById(`${id}Bar`).style.width = `${percentage}%`;
    document.getElementById(`${id}Time`).textContent = `${time}ms`;
  });
}

// ========== F7: æ›´æ–°è´¨é‡è¯„åˆ† ==========
function updateQualityScore(observability) {
  if (!observability || !observability.quality) return;

  const { quality } = observability;
  const { score, checks, warnings } = quality;

  // æ›´æ–°åˆ†æ•°ç¯
  document.getElementById('qualityScore').textContent = score;
  const circumference = 251;
  const offset = circumference - (score / 100) * circumference;
  document.getElementById('qualityCircle').style.strokeDashoffset = offset;

  // æ›´æ–°æ£€æŸ¥é¡¹
  const checksHtml = Object.entries(checks).map(([key, value]) => {
    const icon = value === true || value === 'excellent' || value === 'good' ? 'âœ…' : 'âš ï¸';
    const label = key.replace(/([A-Z])/g, ' $1').trim();
    return `
      <div class="quality-check-item">
        <span class="check-icon">${icon}</span>
        <span class="check-label">${label}</span>
        <span class="check-value">${typeof value === 'boolean' ? (value ? 'é€šè¿‡' : 'å¤±è´¥') : value}</span>
      </div>
    `;
  }).join('');

  document.getElementById('qualityChecks').innerHTML = checksHtml;

  // æ˜¾ç¤ºè­¦å‘Š
  if (warnings && warnings.length) {
    const warningsHtml = warnings.map(w => `<li>${w}</li>`).join('');
    document.getElementById('qualityWarnings').innerHTML = `<ul>${warningsHtml}</ul>`;
    document.getElementById('qualityWarnings').classList.remove('hidden');
  } else {
    document.getElementById('qualityWarnings').classList.add('hidden');
  }
}

// ========== F5: æ›´æ–° Prompt ç»“æ„ ==========
function updatePromptStructure(observability) {
  if (!observability || !observability.prompt) return;

  const { prompt } = observability;

  // å®Œæ•´ Prompt
  document.getElementById('promptFullContent').textContent = prompt.full;

  // ç»“æ„åŒ–è§†å›¾
  const { structure } = prompt;

  document.getElementById('promptSystem').textContent = structure.systemInstruction || '-';

  // CoT æ­¥éª¤
  const cotHtml = structure.chainOfThought.map(step => `<li>${step}</li>`).join('');
  document.getElementById('promptCoT').innerHTML = cotHtml;

  // Few-shot ç¤ºä¾‹
  const examplesHtml = structure.fewShotExamples.map(ex => `
    <details>
      <summary>${ex.title}</summary>
      <pre>${ex.content}</pre>
    </details>
  `).join('');
  document.getElementById('promptExamples').innerHTML = examplesHtml;

  // è´¨é‡æ ‡å‡†
  const standardsHtml = structure.qualityStandards.map(s => `<li>${s}</li>`).join('');
  document.getElementById('promptStandards').innerHTML = standardsHtml;

  document.getElementById('promptUserInput').textContent = structure.userInput;
}

// Prompt æ ‡ç­¾åˆ‡æ¢
document.querySelectorAll('.prompt-tab').forEach(tab => {
  tab.addEventListener('click', (e) => {
    const targetTab = e.target.dataset.tab;

    document.querySelectorAll('.prompt-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.prompt-tab-panel').forEach(p => p.classList.remove('active'));

    e.target.classList.add('active');
    document.getElementById(`prompt${targetTab.charAt(0).toUpperCase() + targetTab.slice(1)}`).classList.add('active');
  });
});

// ========== F3: å¥åº·çŠ¶æ€é¢æ¿ ==========
const healthToggle = document.getElementById('healthToggle');
const healthContent = document.querySelector('.health-content');
const healthRefresh = document.getElementById('healthRefresh');

healthToggle.addEventListener('click', () => {
  healthContent.classList.toggle('hidden');
  if (!healthContent.classList.contains('hidden')) {
    loadHealthStatus();
  }
});

healthRefresh.addEventListener('click', loadHealthStatus);

async function loadHealthStatus() {
  try {
    const response = await fetch('/api/health');
    const data = await response.json();

    // æ¸²æŸ“æœåŠ¡çŠ¶æ€
    const servicesHtml = data.services.map(service => {
      const statusClass = service.status;
      const statusIcon = {
        online: 'ğŸŸ¢',
        offline: 'ğŸ”´',
        degraded: 'ğŸŸ¡',
        unknown: 'âšª'
      }[service.status] || 'âšª';

      return `
        <div class="health-service ${statusClass}">
          <div class="service-header">
            <span class="service-icon">${statusIcon}</span>
            <span class="service-name">${service.name}</span>
          </div>
          <div class="service-info">
            ${service.latency ? `<span class="service-latency">${service.latency}ms</span>` : ''}
            <span class="service-message">${service.message || '-'}</span>
          </div>
        </div>
      `;
    }).join('');

    document.getElementById('healthServices').innerHTML = servicesHtml;

    // æ›´æ–°å­˜å‚¨ä¿¡æ¯
    if (data.storage) {
      const { used, total, percentage } = data.storage;
      const usedGB = (used / (1024 ** 3)).toFixed(2);
      const totalGB = (total / (1024 ** 3)).toFixed(2);

      document.getElementById('storageFill').style.width = `${percentage}%`;
      document.getElementById('storageText').textContent = `${usedGB} GB / ${totalGB} GB (${percentage.toFixed(1)}%)`;
    }

  } catch (error) {
    console.error('[Health] Load error:', error);
  }
}

// å®šæœŸåˆ·æ–°å¥åº·çŠ¶æ€
setInterval(() => {
  if (!healthContent.classList.contains('hidden')) {
    loadHealthStatus();
  }
}, 30000); // æ¯30ç§’

// ========== F9: å¯¹æ¯”æ¨¡å¼ ==========
function showComparisonResult(comparisonData) {
  const modal = document.getElementById('comparisonModal');

  // Gemini ç»“æœ
  if (comparisonData.gemini.success) {
    document.getElementById('geminiStatus').textContent = 'âœ… æˆåŠŸ';
    document.getElementById('geminiMetrics').innerHTML = `
      <div class="metric">è€—æ—¶: ${comparisonData.gemini.observability.performance.totalTime}ms</div>
      <div class="metric">è´¨é‡: ${comparisonData.gemini.observability.quality.score}/100</div>
      <div class="metric">Tokens: ${comparisonData.gemini.observability.tokens.total}</div>
    `;
    document.getElementById('geminiOutput').innerHTML = `
      <pre>${comparisonData.gemini.output.markdown_content.substring(0, 500)}...</pre>
    `;
  } else {
    document.getElementById('geminiStatus').textContent = 'âŒ å¤±è´¥';
    document.getElementById('geminiMetrics').textContent = comparisonData.gemini.error;
  }

  // Local ç»“æœ
  if (comparisonData.local.success) {
    document.getElementById('localStatus').textContent = 'âœ… æˆåŠŸ';
    document.getElementById('localMetrics').innerHTML = `
      <div class="metric">è€—æ—¶: ${comparisonData.local.observability.performance.totalTime}ms</div>
      <div class="metric">è´¨é‡: ${comparisonData.local.observability.quality.score}/100</div>
      <div class="metric">Tokens: ${comparisonData.local.observability.tokens.total}</div>
    `;
    document.getElementById('localOutput').innerHTML = `
      <pre>${comparisonData.local.output.markdown_content.substring(0, 500)}...</pre>
    `;
  } else {
    document.getElementById('localStatus').textContent = 'âŒ å¤±è´¥';
    document.getElementById('localMetrics').textContent = comparisonData.local.error;
  }

  // å¯¹æ¯”æ€»ç»“
  if (comparisonData.comparison) {
    const { winner, metrics, recommendation } = comparisonData.comparison;

    document.getElementById('comparisonWinner').innerHTML = `
      <div class="winner-badge">
        ä¼˜èƒœè€…: ${winner === 'gemini' ? 'ğŸ¤– Gemini' : 'ğŸ–¥ï¸ Local LLM'}
      </div>
    `;

    document.getElementById('comparisonRec').textContent = recommendation;
  }

  modal.classList.remove('hidden');
}

function closeComparisonModal() {
  document.getElementById('comparisonModal').classList.add('hidden');
}

// ========== ä¿®æ”¹ç”ŸæˆæŒ‰é’®é€»è¾‘ ==========
genBtn.addEventListener('click', async () => {
  const phrase = phraseInput.value.trim();
  if (!phrase) return;

  const enableCompare = enableCompareCheckbox.checked;

  state.isGenerating = true;
  genBtn.disabled = true;
  genBtn.textContent = '...';
  ocrBtn.disabled = true;

  try {
    showProgress(phrase);
    updateProgress('generate', enableCompare ? 'æ­£åœ¨è¿›è¡Œæ¨¡å‹å¯¹æ¯”...' : 'æ­£åœ¨è°ƒç”¨ LLM ç”Ÿæˆä¸‰è¯­å†…å®¹...');

    const res = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        phrase,
        llm_provider: state.llmProvider,
        enable_compare: enableCompare  // âœ… æ–°å¢
      })
    });

    const data = await res.json();

    // ===== å¯¹æ¯”æ¨¡å¼ =====
    if (enableCompare && data.comparison) {
      hideProgress();
      showComparisonResult(data);
      return;
    }

    // ===== å•æ¨¡å‹æ¨¡å¼ =====
    updateProgress('save', 'æ­£åœ¨ä¿å­˜æ–‡ä»¶...');

    // æ˜¾ç¤ºå®Œæ•´ Prompt ä¸ LLM è¾“å‡º
    if (data.prompt) {
      showFullPrompt(data.prompt);
    } else {
      hideFullPrompt();
    }
    if (data.llm_output) {
      showFullOutput(data.llm_output);
    } else {
      hideFullOutput();
    }

    // ===== æ›´æ–°å¯è§‚æµ‹æ€§æ•°æ® =====
    if (data.observability) {
      observabilityPanel.classList.remove('hidden');
      updateTokenStats(data.observability);
      updatePerformanceMetrics(data.observability);
      updateQualityScore(data.observability);
      updatePromptStructure(data.observability);
    }

    if (!res.ok) {
      const detail = data.details && Array.isArray(data.details) ? data.details.join('ï¼›') : '';
      const message = detail ? `${data.error}ï¼ˆ${detail}ï¼‰` : data.error;
      throw new Error(message || 'Generation failed');
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰éŸ³é¢‘ç”Ÿæˆ
    if (data.audio && data.audio.results && data.audio.results.length > 0) {
      updateProgress('audio', 'éŸ³é¢‘ç”Ÿæˆå®Œæˆ');
    }

    // æˆåŠŸ
    stopTimer();
    const elapsed = getElapsedTime();
    const savedHtml = data.result.files.find((file) => file.endsWith('.html')) || data.result.files[0];
    updateProgress('audio', `âœ“ å®Œæˆ (${elapsed}) - ${data.result.folder}/${savedHtml}`, false);
    phraseInput.value = '';
    clearImage();

    // Refresh folders and select the new one
    await loadFolders({ targetSelect: data.result.folder });

    setTimeout(hideProgress, 4000);

  } catch (error) {
    console.error(error);
    progressStatus.textContent = 'âœ— é”™è¯¯: ' + error.message;
    progressStatus.style.color = '#f87171';
    setTimeout(() => {
      hideProgress();
      progressStatus.style.color = '';
    }, 5000);
  } finally {
    state.isGenerating = false;
    genBtn.disabled = false;
    genBtn.textContent = 'Generate';
    ocrBtn.disabled = !state.imageBase64;
  }
});
```

### 5.4 CSS æ ·å¼

```css
/* public/observability.css */

/* ========== å¯è§‚æµ‹æ€§é¢æ¿ ========== */
.observability-panel {
  margin-top: 2rem;
  padding: 1.5rem;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.obs-section {
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
}

.obs-title {
  margin: 0 0 1rem 0;
  font-size: 1.1rem;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.9);
}

/* F1: Token ç»Ÿè®¡ */
.token-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem;
  margin-bottom: 1rem;
}

.token-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
}

.token-label {
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.6);
  margin-bottom: 0.5rem;
}

.token-value {
  font-size: 1.5rem;
  font-weight: 600;
  color: #a78bfa;
}

.quota-bar {
  margin-top: 1rem;
}

.quota-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.7);
}

.quota-progress {
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  overflow: hidden;
}

.quota-fill {
  height: 100%;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  transition: width 0.3s ease;
}

.quota-fill.warning {
  background: linear-gradient(90deg, #f59e0b 0%, #ef4444 100%);
}

/* F2: æ€§èƒ½æŒ‡æ ‡ */
.perf-summary {
  text-align: center;
  margin-bottom: 1.5rem;
}

.perf-total {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  padding: 1.5rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.perf-value {
  font-size: 2.5rem;
  font-weight: 700;
  color: #60a5fa;
}

.perf-label {
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.6);
  margin-top: 0.5rem;
}

.perf-breakdown {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.perf-phase {
  display: grid;
  grid-template-columns: 120px 1fr 80px;
  align-items: center;
  gap: 1rem;
}

.phase-name {
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.7);
}

.phase-bar-container {
  height: 24px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  overflow: hidden;
}

.phase-bar {
  height: 100%;
  background: linear-gradient(90deg, #34d399 0%, #10b981 100%);
  transition: width 0.3s ease;
}

.phase-time {
  text-align: right;
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.8);
  font-family: 'JetBrains Mono', monospace;
}

/* F7: è´¨é‡è¯„åˆ† */
.quality-main {
  display: grid;
  grid-template-columns: 200px 1fr;
  gap: 2rem;
}

.quality-circle {
  position: relative;
  width: 150px;
  height: 150px;
  margin: 0 auto;
}

.quality-circle svg {
  width: 100%;
  height: 100%;
  transform: rotate(-90deg);
}

.quality-bg {
  fill: none;
  stroke: rgba(255, 255, 255, 0.1);
  stroke-width: 8;
}

.quality-progress {
  fill: none;
  stroke: url(#qualityGradient);
  stroke-width: 8;
  stroke-linecap: round;
  transition: stroke-dashoffset 0.5s ease;
}

.quality-score-value {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 3rem;
  font-weight: 700;
  color: #a78bfa;
}

.quality-checks {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.quality-check-item {
  display: grid;
  grid-template-columns: 30px 1fr auto;
  align-items: center;
  padding: 0.75rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
}

.check-icon {
  font-size: 1.2rem;
}

.check-label {
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.8);
}

.check-value {
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.6);
  text-transform: capitalize;
}

.quality-warnings {
  margin-top: 1rem;
  padding: 1rem;
  background: rgba(251, 146, 60, 0.1);
  border-left: 3px solid #fb923c;
  border-radius: 4px;
}

.quality-warnings ul {
  margin: 0;
  padding-left: 1.5rem;
  color: #fbbf24;
}

/* F5: Prompt ç»“æ„ */
.prompt-tabs {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.prompt-tab {
  padding: 0.75rem 1.5rem;
  background: none;
  border: none;
  color: rgba(255, 255, 255, 0.6);
  cursor: pointer;
  transition: all 0.2s;
  border-bottom: 2px solid transparent;
}

.prompt-tab:hover {
  color: rgba(255, 255, 255, 0.9);
}

.prompt-tab.active {
  color: #a78bfa;
  border-bottom-color: #a78bfa;
}

.prompt-tab-panel {
  display: none;
}

.prompt-tab-panel.active {
  display: block;
}

.prompt-section {
  margin-bottom: 1.5rem;
}

.prompt-section h5 {
  margin: 0 0 0.75rem 0;
  font-size: 1rem;
  color: rgba(255, 255, 255, 0.8);
}

.prompt-section pre {
  padding: 1rem;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 6px;
  font-size: 0.85rem;
  line-height: 1.6;
  overflow-x: auto;
  color: rgba(255, 255, 255, 0.9);
}

.prompt-section ol,
.prompt-section ul {
  margin: 0;
  padding-left: 1.5rem;
  color: rgba(255, 255, 255, 0.8);
}

.prompt-section details {
  margin-bottom: 0.5rem;
  padding: 0.75rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
}

.prompt-section summary {
  cursor: pointer;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
}

/* F3: å¥åº·çŠ¶æ€é¢æ¿ */
.health-panel {
  position: fixed;
  right: 20px;
  top: 100px;
  z-index: 100;
}

.health-toggle {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1.25rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: none;
  border-radius: 8px;
  color: white;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  transition: all 0.2s;
}

.health-toggle:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
}

.health-content {
  margin-top: 1rem;
  padding: 1.5rem;
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  min-width: 300px;
  max-width: 400px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

.health-services {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1.5rem;
}

.health-service {
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  border-left: 3px solid transparent;
}

.health-service.online {
  border-left-color: #10b981;
}

.health-service.offline {
  border-left-color: #ef4444;
}

.health-service.degraded {
  border-left-color: #f59e0b;
}

.service-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
}

.service-name {
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
}

.service-info {
  display: flex;
  justify-content: space-between;
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.6);
}

.health-storage {
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.storage-bar {
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  margin: 0.5rem 0;
  overflow: hidden;
}

.storage-fill {
  height: 100%;
  background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
  transition: width 0.3s ease;
}

/* F9: å¯¹æ¯”è§†å›¾ */
.comparison-controls {
  margin-top: 1rem;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.comparison-toggle {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
}

.comparison-view {
  max-width: 1200px;
  padding: 2rem;
}

.comparison-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
  margin-bottom: 2rem;
}

.comparison-panel {
  padding: 1.5rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  border: 2px solid rgba(255, 255, 255, 0.1);
}

.comparison-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.comparison-header.gemini {
  border-color: #667eea;
}

.comparison-header.local {
  border-color: #10b981;
}

.comparison-metrics {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.comparison-output {
  max-height: 300px;
  overflow-y: auto;
}

.comparison-summary {
  padding: 1.5rem;
  background: rgba(102, 126, 234, 0.1);
  border-radius: 12px;
  border: 2px solid #667eea;
}

.winner-badge {
  display: inline-block;
  padding: 0.75rem 1.5rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 8px;
  font-size: 1.2rem;
  font-weight: 600;
  color: white;
  margin-bottom: 1rem;
}

/* å“åº”å¼ */
@media (max-width: 768px) {
  .token-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .quality-main {
    grid-template-columns: 1fr;
  }

  .comparison-grid {
    grid-template-columns: 1fr;
  }

  .health-panel {
    right: 10px;
    top: 80px;
  }
}
```

---

## 6. å®ç°æ­¥éª¤

### é˜¶æ®µ 1: åç«¯åŸºç¡€è®¾æ–½ï¼ˆ2-3å¤©ï¼‰

**Day 1: å¯è§‚æµ‹æ€§æœåŠ¡**
- [ ] åˆ›å»º `services/observabilityService.js`
- [ ] å®ç° `TokenCounter` ç±»
- [ ] å®ç° `PerformanceMonitor` ç±»
- [ ] å®ç° `QualityChecker` ç±»
- [ ] å®ç° `PromptParser` ç±»
- [ ] å•å…ƒæµ‹è¯•

**Day 2: å¥åº·æ£€æŸ¥æœåŠ¡**
- [ ] åˆ›å»º `services/healthCheckService.js`
- [ ] å®ç°å„æœåŠ¡å¥åº·æ£€æŸ¥æ–¹æ³•
- [ ] æ·»åŠ  `/api/health` ç«¯ç‚¹
- [ ] æµ‹è¯•å¥åº·æ£€æŸ¥åŠŸèƒ½

**Day 3: å¢å¼º Generate API**
- [ ] ä¿®æ”¹ `/api/generate` é›†æˆå¯è§‚æµ‹æ€§æ•°æ®
- [ ] å®ç°å¯¹æ¯”æ¨¡å¼é€»è¾‘
- [ ] æµ‹è¯•å•æ¨¡å‹ä¸å¯¹æ¯”æ¨¡å¼
- [ ] ä¼˜åŒ–æ€§èƒ½ç›‘æ§

### é˜¶æ®µ 2: å‰ç«¯ UI å¼€å‘ï¼ˆ3-4å¤©ï¼‰

**Day 4-5: å¯è§‚æµ‹æ€§é¢æ¿**
- [ ] æ·»åŠ  HTML ç»“æ„
- [ ] å®ç° Token ç»Ÿè®¡ç»„ä»¶
- [ ] å®ç°æ€§èƒ½æŒ‡æ ‡ç»„ä»¶
- [ ] å®ç°è´¨é‡è¯„åˆ†ç»„ä»¶
- [ ] å®ç° Prompt ç»“æ„åŒ–è§†å›¾

**Day 6: å¥åº·çŠ¶æ€é¢æ¿**
- [ ] å®ç°å¥åº·çŠ¶æ€ UI
- [ ] é›†æˆ `/api/health` API
- [ ] æ·»åŠ è‡ªåŠ¨åˆ·æ–°æœºåˆ¶
- [ ] æ ·å¼ä¼˜åŒ–

**Day 7: å¯¹æ¯”æ¨¡å¼ UI**
- [ ] å®ç°å¯¹æ¯”æ¨¡å¼åˆ‡æ¢
- [ ] å®ç°å¯¹æ¯”ç»“æœæ˜¾ç¤º
- [ ] æ ·å¼è°ƒæ•´
- [ ] äº¤äº’ä¼˜åŒ–

### é˜¶æ®µ 3: é›†æˆæµ‹è¯•ä¸ä¼˜åŒ–ï¼ˆ1-2å¤©ï¼‰

**Day 8: é›†æˆæµ‹è¯•**
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] è¾¹ç•Œæƒ…å†µæµ‹è¯•
- [ ] Bug ä¿®å¤

**Day 9: æ–‡æ¡£ä¸ä¼˜åŒ–**
- [ ] æ›´æ–°ç”¨æˆ·æ–‡æ¡£
- [ ] ä»£ç æ³¨é‡Šå®Œå–„
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] å‘å¸ƒå‡†å¤‡

---

## 7. æµ‹è¯•è®¡åˆ’

### 7.1 å•å…ƒæµ‹è¯•

```javascript
// tests/observability.test.js

const { TokenCounter, QualityChecker, PromptParser } = require('../services/observabilityService');

describe('TokenCounter', () => {
  test('should estimate tokens correctly', () => {
    const text = 'Hello world this is a test';
    const tokens = TokenCounter.estimate(text);
    expect(tokens).toBeGreaterThan(0);
  });

  test('should calculate cost for gemini', () => {
    const tokens = { input: 1000, output: 500, total: 1500 };
    const cost = TokenCounter.calculateCost(tokens, 'gemini');
    expect(cost.total).toBe(0); // Free tier
  });
});

describe('QualityChecker', () => {
  test('should check valid content', () => {
    const content = {
      markdown_content: '# Test\n## Section\n1. Example sentence',
      html_content: '<html>...</html>',
      audio_tasks: [{ text: 'test', lang: 'en', filename_suffix: '_en_1' }]
    };

    const result = QualityChecker.check(content, 'test');
    expect(result.score).toBeGreaterThan(0);
    expect(result.checks.jsonValid).toBe(true);
  });
});
```

### 7.2 é›†æˆæµ‹è¯•

```javascript
// tests/api.integration.test.js

describe('POST /api/generate', () => {
  test('should return observability data', async () => {
    const response = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ phrase: 'hello' })
    });

    const data = await response.json();

    expect(data.observability).toBeDefined();
    expect(data.observability.tokens).toBeDefined();
    expect(data.observability.performance).toBeDefined();
    expect(data.observability.quality).toBeDefined();
  });

  test('should support comparison mode', async () => {
    const response = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        phrase: 'hello',
        enable_compare: true
      })
    });

    const data = await response.json();

    expect(data.comparison).toBeDefined();
    expect(data.gemini).toBeDefined();
    expect(data.local).toBeDefined();
  });
});

describe('GET /api/health', () => {
  test('should return health status', async () => {
    const response = await fetch('/api/health');
    const data = await response.json();

    expect(data.services).toBeDefined();
    expect(Array.isArray(data.services)).toBe(true);
    expect(data.storage).toBeDefined();
    expect(data.system).toBeDefined();
  });
});
```

### 7.3 E2E æµ‹è¯•

- ç”¨æˆ·ç”Ÿæˆå¡ç‰‡ â†’ æŸ¥çœ‹å¯è§‚æµ‹æ€§æ•°æ®
- ç”¨æˆ·åˆ‡æ¢ provider â†’ å¯¹æ¯”ç”Ÿæˆç»“æœ
- ç”¨æˆ·æŸ¥çœ‹å¥åº·çŠ¶æ€ â†’ æ£€æŸ¥æœåŠ¡çŠ¶æ€
- ç”¨æˆ·æŸ¥çœ‹ Prompt ç»“æ„ â†’ æ£€æŸ¥åˆ†æ®µæ˜¾ç¤º

---

## é™„å½•

### A. ç¯å¢ƒå˜é‡æ›´æ–°

```env
# .env æ–°å¢é…ç½®

# å¯è§‚æµ‹æ€§é…ç½®
ENABLE_OBSERVABILITY=true
ENABLE_PERFORMANCE_MONITORING=true
ENABLE_QUALITY_CHECKING=true

# å¥åº·æ£€æŸ¥é…ç½®
HEALTH_CHECK_INTERVAL=30000  # 30ç§’
HEALTH_CHECK_TIMEOUT=5000    # 5ç§’

# å¯¹æ¯”æ¨¡å¼é…ç½®
ENABLE_COMPARISON_MODE=true
COMPARISON_TIMEOUT=10000     # 10ç§’
```

### B. æ•°æ®åº“è®¾è®¡ï¼ˆå¯é€‰ï¼‰

å¦‚éœ€æŒä¹…åŒ–å¯è§‚æµ‹æ€§æ•°æ®ï¼š

```sql
CREATE TABLE observability_logs (
  id SERIAL PRIMARY KEY,
  request_id VARCHAR(255) UNIQUE,
  phrase TEXT,
  provider VARCHAR(50),
  tokens_input INTEGER,
  tokens_output INTEGER,
  tokens_total INTEGER,
  cost_total DECIMAL(10, 6),
  performance_total_time INTEGER,
  quality_score INTEGER,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_created_at ON observability_logs(created_at);
CREATE INDEX idx_provider ON observability_logs(provider);
```

### C. æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç¼“å­˜**: å¯¹ Prompt æ¨¡æ¿ã€å¥åº·çŠ¶æ€è¿›è¡Œç¼“å­˜
2. **æ‡’åŠ è½½**: å¯è§‚æµ‹æ€§é¢æ¿åˆå§‹æŠ˜å ï¼Œç‚¹å‡»å±•å¼€
3. **é‡‡æ ·**: é«˜é¢‘ä½¿ç”¨æ—¶ï¼Œå¯è€ƒè™‘é‡‡æ ·è®°å½•ï¼ˆå¦‚ 10% è¯·æ±‚ï¼‰
4. **å¼‚æ­¥**: è´¨é‡æ£€æŸ¥ã€æ—¥å¿—è®°å½•å¼‚æ­¥æ‰§è¡Œ

---

**æ–‡æ¡£ç»“æŸ**

æœ€åæ›´æ–°: 2026-02-02
ç»´æŠ¤è€…: Development Team

# 三语卡片生成系统 - 数据库设计方案

## 📋 目录

1. [设计目标](#设计目标)
2. [数据库选型](#数据库选型)
3. [表结构设计](#表结构设计)
4. [索引设计](#索引设计)
5. [API集成](#api集成)
6. [数据迁移](#数据迁移)
7. [查询示例](#查询示例)
8. [实施计划](#实施计划)

---

## 🎯 设计目标

### 核心需求
1. ✅ **完整记录**：每次生成的所有数据（短语、翻译、音频路径、文件路径）
2. ✅ **可观测性**：Token统计、性能指标、质量评分
3. ✅ **历史追溯**：查看任意时间的生成记录
4. ✅ **质量分析**：统计分析模型质量、对比不同模型
5. ✅ **全文搜索**：快速查找短语、翻译内容

### 性能要求
- **写入**：每次生成插入1条记录（~10ms）
- **查询**：分页查询历史记录（<50ms）
- **分析**：聚合统计（<200ms）
- **存储**：单条记录 ~5KB，1万条记录 ~50MB

---

## 🗄️ 数据库选型

### 方案对比

| 数据库 | 优势 | 劣势 | 适用场景 | 推荐度 |
|--------|------|------|---------|--------|
| **SQLite** | 零配置、轻量、单文件、跨平台 | 并发写入弱、无网络访问 | 桌面应用、个人使用 | ⭐⭐⭐⭐⭐ |
| **PostgreSQL** | 功能强大、JSON支持、全文搜索 | 需要安装服务、配置复杂 | 生产环境、多用户 | ⭐⭐⭐⭐ |
| **MongoDB** | Schema灵活、文档型 | 占用空间大、学习成本 | 快速迭代、大数据 | ⭐⭐⭐ |

### 推荐方案：SQLite + better-sqlite3

**选择理由：**
1. ✅ 零配置，单文件数据库（`trilingual_records.db`）
2. ✅ 完美适配桌面应用（M4芯片）
3. ✅ `better-sqlite3` 性能优秀，同步API
4. ✅ 支持JSON1扩展（存储可观测性数据）
5. ✅ 支持FTS5全文搜索
6. ✅ 易于备份和迁移

**可选升级：**
- 如需多用户访问，可迁移到PostgreSQL
- 保持相同的表结构和API接口

---

## 📊 表结构设计

### 1. generations（生成记录主表）

存储每次卡片生成的核心信息。

```sql
CREATE TABLE generations (
  -- 主键
  id INTEGER PRIMARY KEY AUTOINCREMENT,

  -- 基本信息
  phrase TEXT NOT NULL,                    -- 输入短语
  phrase_language TEXT,                    -- 短语语言（zh/en/ja）

  -- 提供商信息
  llm_provider TEXT NOT NULL,              -- LLM提供商（local/gemini）
  llm_model TEXT,                          -- 模型名称（qwen2_5_vl/gemini-2.5-flash）

  -- 文件路径
  folder_name TEXT NOT NULL,               -- 文件夹名称（YYYYMMDD）
  base_filename TEXT NOT NULL,             -- 基础文件名
  md_file_path TEXT NOT NULL,              -- Markdown文件路径
  html_file_path TEXT NOT NULL,            -- HTML文件路径
  meta_file_path TEXT,                     -- Meta文件路径

  -- 内容（存储为TEXT，便于全文搜索）
  markdown_content TEXT NOT NULL,          -- 完整Markdown内容

  -- 翻译内容（提取关键字段，便于查询）
  en_translation TEXT,                     -- 英文翻译
  ja_translation TEXT,                     -- 日语翻译
  zh_translation TEXT,                     -- 中文翻译

  -- 时间戳
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  -- 索引列
  generation_date DATE,                    -- 生成日期（YYYY-MM-DD）

  -- 元数据
  request_id TEXT UNIQUE,                  -- 请求唯一ID
  user_agent TEXT,                         -- 用户代理
  ip_address TEXT                          -- IP地址（如果有）
);

-- 索引
CREATE INDEX idx_generations_phrase ON generations(phrase);
CREATE INDEX idx_generations_date ON generations(generation_date DESC);
CREATE INDEX idx_generations_provider ON generations(llm_provider);
CREATE INDEX idx_generations_created_at ON generations(created_at DESC);
CREATE INDEX idx_generations_request_id ON generations(request_id);

-- 全文搜索索引
CREATE VIRTUAL TABLE generations_fts USING fts5(
  phrase,
  en_translation,
  ja_translation,
  zh_translation,
  markdown_content,
  content=generations,
  content_rowid=id
);

-- FTS触发器（自动同步）
CREATE TRIGGER generations_fts_insert AFTER INSERT ON generations BEGIN
  INSERT INTO generations_fts(rowid, phrase, en_translation, ja_translation, zh_translation, markdown_content)
  VALUES (new.id, new.phrase, new.en_translation, new.ja_translation, new.zh_translation, new.markdown_content);
END;

CREATE TRIGGER generations_fts_delete AFTER DELETE ON generations BEGIN
  DELETE FROM generations_fts WHERE rowid = old.id;
END;

CREATE TRIGGER generations_fts_update AFTER UPDATE ON generations BEGIN
  DELETE FROM generations_fts WHERE rowid = old.id;
  INSERT INTO generations_fts(rowid, phrase, en_translation, ja_translation, zh_translation, markdown_content)
  VALUES (new.id, new.phrase, new.en_translation, new.ja_translation, new.zh_translation, new.markdown_content);
END;
```

### 2. audio_files（音频文件记录）

存储每个音频文件的详细信息。

```sql
CREATE TABLE audio_files (
  id INTEGER PRIMARY KEY AUTOINCREMENT,

  -- 关联生成记录
  generation_id INTEGER NOT NULL,

  -- 音频信息
  language TEXT NOT NULL,                  -- 语言（en/ja）
  text TEXT NOT NULL,                      -- 音频对应文本
  filename_suffix TEXT NOT NULL,           -- 文件名后缀（_en_1/_ja_2等）
  file_path TEXT NOT NULL,                 -- 完整文件路径

  -- TTS服务信息
  tts_provider TEXT,                       -- TTS提供商（kokoro/voicevox）
  tts_model TEXT,                          -- TTS模型
  tts_voice TEXT,                          -- 语音名称

  -- 音频元数据
  file_size INTEGER,                       -- 文件大小（bytes）
  duration REAL,                           -- 音频时长（秒）
  sample_rate INTEGER,                     -- 采样率
  format TEXT,                             -- 音频格式（wav/mp3）

  -- 生成状态
  status TEXT DEFAULT 'pending',           -- pending/generated/failed
  error_message TEXT,                      -- 错误信息

  -- 时间戳
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  generated_at DATETIME,

  FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE
);

CREATE INDEX idx_audio_generation ON audio_files(generation_id);
CREATE INDEX idx_audio_language ON audio_files(language);
CREATE INDEX idx_audio_status ON audio_files(status);
```

### 3. observability_metrics（可观测性指标）

存储每次生成的完整可观测性数据。

```sql
CREATE TABLE observability_metrics (
  id INTEGER PRIMARY KEY AUTOINCREMENT,

  -- 关联生成记录
  generation_id INTEGER NOT NULL UNIQUE,

  -- Token统计
  tokens_input INTEGER,                    -- 输入tokens
  tokens_output INTEGER,                   -- 输出tokens
  tokens_total INTEGER,                    -- 总tokens
  tokens_cached INTEGER DEFAULT 0,         -- 缓存tokens

  -- 成本估算
  cost_input REAL,                         -- 输入成本
  cost_output REAL,                        -- 输出成本
  cost_total REAL,                         -- 总成本
  cost_currency TEXT DEFAULT 'USD',

  -- 配额信息
  quota_used INTEGER,                      -- 已使用配额
  quota_limit INTEGER,                     -- 配额限制
  quota_remaining INTEGER,                 -- 剩余配额
  quota_reset_at DATETIME,                 -- 配额重置时间
  quota_percentage REAL,                   -- 配额使用百分比

  -- 性能指标（JSON存储详细数据）
  performance_total_ms INTEGER,            -- 总耗时（毫秒）
  performance_phases JSON,                 -- 各阶段耗时详情
  /*
  {
    "promptBuild": 50,
    "llmCall": 8000,
    "jsonParse": 100,
    "fileSave": 200,
    "audioGenerate": 3000
  }
  */

  -- 质量评分
  quality_score INTEGER,                   -- 总质量分（0-100）
  quality_checks JSON,                     -- 质量检查详情
  quality_dimensions JSON,                 -- 质量维度详情
  quality_warnings JSON,                   -- 质量警告列表
  /*
  {
    "structureIntegrity": 25,
    "contentRichness": 20,
    "formatCompliance": 22,
    "audioCompleteness": 0
  }
  */

  -- Prompt信息（JSON存储完整结构）
  prompt_full TEXT,                        -- 完整Prompt文本
  prompt_parsed JSON,                      -- 解析后的Prompt结构
  /*
  {
    "systemInstruction": "...",
    "chainOfThought": [...],
    "fewShotExamples": [...],
    "qualityStandards": [...],
    "userInput": "..."
  }
  */

  -- LLM原始输出
  llm_output TEXT,                         -- LLM完整输出
  llm_finish_reason TEXT,                  -- 完成原因（STOP/MAX_TOKENS/ERROR）

  -- 元数据
  metadata JSON,                           -- 其他元数据
  /*
  {
    "provider": "local",
    "model": "qwen2_5_vl",
    "timestamp": 1234567890,
    "requestId": "...",
    "serverVersion": "1.0.0"
  }
  */

  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE
);

CREATE INDEX idx_obs_generation ON observability_metrics(generation_id);
CREATE INDEX idx_obs_quality ON observability_metrics(quality_score DESC);
CREATE INDEX idx_obs_tokens ON observability_metrics(tokens_total DESC);
CREATE INDEX idx_obs_cost ON observability_metrics(cost_total DESC);
```

### 4. generation_errors（生成错误记录）

记录失败的生成请求，便于调试和分析。

```sql
CREATE TABLE generation_errors (
  id INTEGER PRIMARY KEY AUTOINCREMENT,

  -- 请求信息
  phrase TEXT NOT NULL,
  llm_provider TEXT NOT NULL,
  request_id TEXT,

  -- 错误信息
  error_type TEXT,                         -- 错误类型（VALIDATION/API/TIMEOUT）
  error_message TEXT NOT NULL,
  error_stack TEXT,                        -- 错误堆栈

  -- 上下文信息
  prompt TEXT,                             -- 使用的Prompt
  llm_response TEXT,                       -- LLM响应（如果有）
  validation_errors JSON,                  -- 验证错误详情

  -- 重试信息
  retry_count INTEGER DEFAULT 0,
  retry_success BOOLEAN DEFAULT FALSE,

  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  resolved_at DATETIME
);

CREATE INDEX idx_errors_type ON generation_errors(error_type);
CREATE INDEX idx_errors_created ON generation_errors(created_at DESC);
```

### 5. model_statistics（模型统计）

聚合统计不同模型的表现，便于对比分析。

```sql
CREATE TABLE model_statistics (
  id INTEGER PRIMARY KEY AUTOINCREMENT,

  -- 模型信息
  llm_provider TEXT NOT NULL,
  llm_model TEXT NOT NULL,

  -- 统计周期
  stat_date DATE NOT NULL,                 -- 统计日期
  stat_period TEXT NOT NULL,               -- 统计周期（daily/weekly/monthly）

  -- 使用统计
  total_requests INTEGER DEFAULT 0,
  successful_requests INTEGER DEFAULT 0,
  failed_requests INTEGER DEFAULT 0,
  success_rate REAL,                       -- 成功率

  -- Token统计
  avg_tokens_input REAL,
  avg_tokens_output REAL,
  total_tokens INTEGER,

  -- 成本统计
  total_cost REAL,
  avg_cost_per_request REAL,

  -- 性能统计
  avg_response_time_ms REAL,
  p50_response_time_ms INTEGER,
  p95_response_time_ms INTEGER,
  p99_response_time_ms INTEGER,

  -- 质量统计
  avg_quality_score REAL,
  min_quality_score INTEGER,
  max_quality_score INTEGER,

  -- 更新时间
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  UNIQUE(llm_provider, llm_model, stat_date, stat_period)
);

CREATE INDEX idx_stats_provider ON model_statistics(llm_provider, llm_model);
CREATE INDEX idx_stats_date ON model_statistics(stat_date DESC);
```

### 6. system_health（系统健康历史）

记录系统健康检查的历史数据。

```sql
CREATE TABLE system_health (
  id INTEGER PRIMARY KEY AUTOINCREMENT,

  -- 服务状态（JSON存储完整数据）
  services JSON NOT NULL,
  /*
  [
    {
      "name": "Local LLM",
      "type": "llm",
      "status": "online",
      "latency": 30,
      "details": {...}
    },
    ...
  ]
  */

  -- 存储状态
  storage_used INTEGER,
  storage_total INTEGER,
  storage_percentage REAL,
  records_count INTEGER,

  -- 系统信息
  system_uptime INTEGER,
  system_version TEXT,

  checked_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_health_checked ON system_health(checked_at DESC);
```

---

## 🔍 索引设计

### 复合索引

```sql
-- 按日期和提供商查询
CREATE INDEX idx_gen_date_provider ON generations(generation_date DESC, llm_provider);

-- 按质量评分和日期查询
CREATE INDEX idx_obs_quality_date ON observability_metrics(quality_score DESC, created_at DESC);

-- 按成本和提供商查询
CREATE INDEX idx_obs_cost_provider ON observability_metrics(cost_total DESC)
  WHERE cost_total > 0;
```

### 部分索引

```sql
-- 仅索引成功的生成
CREATE INDEX idx_audio_generated ON audio_files(generation_id)
  WHERE status = 'generated';

-- 仅索引有错误的记录
CREATE INDEX idx_errors_unresolved ON generation_errors(created_at DESC)
  WHERE resolved_at IS NULL;
```

---

## 🔌 API集成

### 数据库服务封装

**文件**: `services/databaseService.js`

```javascript
const Database = require('better-sqlite3');
const path = require('path');

class DatabaseService {
  constructor(dbPath = './data/trilingual_records.db') {
    this.db = new Database(dbPath, { verbose: console.log });
    this.db.pragma('journal_mode = WAL'); // 性能优化
    this.db.pragma('foreign_keys = ON');  // 启用外键
    this.initializeTables();
  }

  initializeTables() {
    // 读取并执行schema.sql
    const schema = fs.readFileSync('./database/schema.sql', 'utf-8');
    this.db.exec(schema);
  }

  // ========== 写入操作 ==========

  /**
   * 插入生成记录（事务）
   */
  insertGeneration(data) {
    const transaction = this.db.transaction((genData, obsData, audioData) => {
      // 1. 插入主记录
      const genInsert = this.db.prepare(`
        INSERT INTO generations (
          phrase, phrase_language, llm_provider, llm_model,
          folder_name, base_filename, md_file_path, html_file_path, meta_file_path,
          markdown_content, en_translation, ja_translation, zh_translation,
          generation_date, request_id
        ) VALUES (
          @phrase, @phraseLanguage, @llmProvider, @llmModel,
          @folderName, @baseFilename, @mdFilePath, @htmlFilePath, @metaFilePath,
          @markdownContent, @enTranslation, @jaTranslation, @zhTranslation,
          @generationDate, @requestId
        )
      `);
      const genResult = genInsert.run(genData);
      const generationId = genResult.lastInsertRowid;

      // 2. 插入可观测性指标
      const obsInsert = this.db.prepare(`
        INSERT INTO observability_metrics (
          generation_id, tokens_input, tokens_output, tokens_total,
          cost_input, cost_output, cost_total,
          quota_used, quota_limit, quota_remaining, quota_percentage,
          performance_total_ms, performance_phases,
          quality_score, quality_checks, quality_dimensions, quality_warnings,
          prompt_full, prompt_parsed, llm_output, llm_finish_reason, metadata
        ) VALUES (
          @generationId, @tokensInput, @tokensOutput, @tokensTotal,
          @costInput, @costOutput, @costTotal,
          @quotaUsed, @quotaLimit, @quotaRemaining, @quotaPercentage,
          @performanceTotalMs, @performancePhases,
          @qualityScore, @qualityChecks, @qualityDimensions, @qualityWarnings,
          @promptFull, @promptParsed, @llmOutput, @llmFinishReason, @metadata
        )
      `);
      obsInsert.run({ ...obsData, generationId });

      // 3. 插入音频文件记录
      const audioInsert = this.db.prepare(`
        INSERT INTO audio_files (
          generation_id, language, text, filename_suffix, file_path,
          tts_provider, status
        ) VALUES (@generationId, @language, @text, @filenameSuffix, @filePath, @ttsProvider, @status)
      `);
      for (const audio of audioData) {
        audioInsert.run({ ...audio, generationId });
      }

      return generationId;
    });

    return transaction(data.generation, data.observability, data.audioFiles);
  }

  /**
   * 记录错误
   */
  insertError(errorData) {
    const stmt = this.db.prepare(`
      INSERT INTO generation_errors (
        phrase, llm_provider, request_id, error_type, error_message,
        error_stack, prompt, llm_response, validation_errors
      ) VALUES (
        @phrase, @llmProvider, @requestId, @errorType, @errorMessage,
        @errorStack, @prompt, @llmResponse, @validationErrors
      )
    `);
    return stmt.run(errorData);
  }

  // ========== 查询操作 ==========

  /**
   * 分页查询历史记录
   */
  queryGenerations({ page = 1, limit = 20, provider, dateFrom, dateTo, search }) {
    let sql = `
      SELECT g.*,
        (SELECT COUNT(*) FROM audio_files WHERE generation_id = g.id AND status = 'generated') as audio_count,
        om.quality_score, om.tokens_total, om.cost_total, om.performance_total_ms
      FROM generations g
      LEFT JOIN observability_metrics om ON g.id = om.generation_id
      WHERE 1=1
    `;
    const params = {};

    if (provider) {
      sql += ` AND g.llm_provider = @provider`;
      params.provider = provider;
    }
    if (dateFrom) {
      sql += ` AND g.generation_date >= @dateFrom`;
      params.dateFrom = dateFrom;
    }
    if (dateTo) {
      sql += ` AND g.generation_date <= @dateTo`;
      params.dateTo = dateTo;
    }
    if (search) {
      // 使用FTS全文搜索
      sql += ` AND g.id IN (
        SELECT rowid FROM generations_fts WHERE generations_fts MATCH @search
      )`;
      params.search = search;
    }

    sql += ` ORDER BY g.created_at DESC LIMIT @limit OFFSET @offset`;
    params.limit = limit;
    params.offset = (page - 1) * limit;

    const stmt = this.db.prepare(sql);
    return stmt.all(params);
  }

  /**
   * 获取单条记录详情
   */
  getGenerationById(id) {
    const generation = this.db.prepare(`
      SELECT * FROM generations WHERE id = ?
    `).get(id);

    if (!generation) return null;

    const observability = this.db.prepare(`
      SELECT * FROM observability_metrics WHERE generation_id = ?
    `).get(id);

    const audioFiles = this.db.prepare(`
      SELECT * FROM audio_files WHERE generation_id = ? ORDER BY filename_suffix
    `).all(id);

    return {
      ...generation,
      observability: observability ? {
        ...observability,
        performance_phases: JSON.parse(observability.performance_phases || '{}'),
        quality_checks: JSON.parse(observability.quality_checks || '[]'),
        quality_dimensions: JSON.parse(observability.quality_dimensions || '{}'),
        quality_warnings: JSON.parse(observability.quality_warnings || '[]'),
        prompt_parsed: JSON.parse(observability.prompt_parsed || '{}'),
        metadata: JSON.parse(observability.metadata || '{}')
      } : null,
      audioFiles
    };
  }

  /**
   * 统计分析
   */
  getStatistics({ provider, dateFrom, dateTo }) {
    const sql = `
      SELECT
        g.llm_provider,
        g.llm_model,
        COUNT(*) as total_count,
        AVG(om.tokens_total) as avg_tokens,
        AVG(om.cost_total) as avg_cost,
        AVG(om.quality_score) as avg_quality,
        AVG(om.performance_total_ms) as avg_response_time,
        SUM(om.cost_total) as total_cost
      FROM generations g
      LEFT JOIN observability_metrics om ON g.id = om.generation_id
      WHERE g.generation_date BETWEEN @dateFrom AND @dateTo
        ${provider ? 'AND g.llm_provider = @provider' : ''}
      GROUP BY g.llm_provider, g.llm_model
      ORDER BY total_count DESC
    `;

    return this.db.prepare(sql).all({ dateFrom, dateTo, provider });
  }

  /**
   * 全文搜索
   */
  fullTextSearch(query, limit = 20) {
    const sql = `
      SELECT g.*,
        snippet(generations_fts, 4, '<mark>', '</mark>', '...', 30) as snippet,
        rank
      FROM generations_fts
      JOIN generations g ON generations_fts.rowid = g.id
      WHERE generations_fts MATCH @query
      ORDER BY rank
      LIMIT @limit
    `;
    return this.db.prepare(sql).all({ query, limit });
  }

  close() {
    this.db.close();
  }
}

module.exports = new DatabaseService();
```

### Server.js集成

```javascript
// 在生成成功后插入数据库
const dbService = require('./services/databaseService');

app.post('/api/generate', async (req, res) => {
  // ... 现有生成逻辑 ...

  try {
    // 保存到数据库
    const generationId = dbService.insertGeneration({
      generation: {
        phrase,
        phraseLanguage: detectLanguage(phrase),
        llmProvider: llm_provider,
        llmModel: observability.metadata.model,
        folderName,
        baseFilename: baseName,
        mdFilePath: result.mdPath,
        htmlFilePath: result.htmlPath,
        metaFilePath: result.metaPath,
        markdownContent: content.markdown_content,
        enTranslation: extractTranslation(content, 'en'),
        jaTranslation: extractTranslation(content, 'ja'),
        zhTranslation: extractTranslation(content, 'zh'),
        generationDate: new Date().toISOString().split('T')[0],
        requestId: generateRequestId()
      },
      observability: {
        tokensInput: observability.tokens.input,
        tokensOutput: observability.tokens.output,
        tokensTotal: observability.tokens.total,
        costInput: observability.cost.input,
        costOutput: observability.cost.output,
        costTotal: observability.cost.total,
        quotaUsed: observability.quota?.used,
        quotaLimit: observability.quota?.limit,
        quotaRemaining: observability.quota?.remaining,
        quotaPercentage: observability.quota?.percentage,
        performanceTotalMs: observability.performance.totalTime,
        performancePhases: JSON.stringify(observability.performance.phases),
        qualityScore: observability.quality.score,
        qualityChecks: JSON.stringify(observability.quality.checks),
        qualityDimensions: JSON.stringify(observability.quality.dimensions),
        qualityWarnings: JSON.stringify(observability.quality.warnings),
        promptFull: prompt,
        promptParsed: JSON.stringify(observability.prompt),
        llmOutput: JSON.stringify(content),
        llmFinishReason: 'STOP',
        metadata: JSON.stringify(observability.metadata)
      },
      audioFiles: (audio.tasks || []).map(task => ({
        language: task.lang,
        text: task.text,
        filenameSuffix: task.filename_suffix,
        filePath: task.filePath,
        ttsProvider: task.lang === 'en' ? 'kokoro' : 'voicevox',
        status: task.status || 'pending'
      }))
    });

    res.json({
      success: true,
      generationId, // 返回数据库ID
      // ... 其他响应数据
    });
  } catch (dbError) {
    console.error('[DB] Insert failed:', dbError);
    // 即使数据库插入失败，也不影响主流程
  }
});
```

---

## 🔄 数据迁移

### 从现有文件系统迁移

**脚本**: `scripts/migrate-to-database.js`

```javascript
const fs = require('fs');
const path = require('path');
const dbService = require('../services/databaseService');

function migrateExistingRecords(recordsPath) {
  const folders = fs.readdirSync(recordsPath).filter(f => /^\d{8}$/.test(f));

  let migrated = 0;
  let failed = 0;

  for (const folder of folders) {
    const folderPath = path.join(recordsPath, folder);
    const files = fs.readdirSync(folderPath);

    // 按base filename分组
    const groups = {};
    for (const file of files) {
      const match = file.match(/^(.+?)\.(md|html|meta\.json)$/);
      if (match) {
        const baseName = match[1];
        if (!groups[baseName]) groups[baseName] = {};
        groups[baseName][match[2]] = file;
      }
    }

    // 迁移每组文件
    for (const [baseName, fileGroup] of Object.entries(groups)) {
      try {
        const mdPath = path.join(folderPath, fileGroup.md);
        const htmlPath = path.join(folderPath, fileGroup.html);
        const metaPath = fileGroup['meta.json'] ?
          path.join(folderPath, fileGroup['meta.json']) : null;

        const mdContent = fs.readFileSync(mdPath, 'utf-8');
        const metaContent = metaPath ?
          JSON.parse(fs.readFileSync(metaPath, 'utf-8')) : {};

        // 提取phrase（从markdown第一行）
        const phrase = mdContent.match(/^# (.+)$/m)?.[1] || baseName;

        dbService.insertGeneration({
          generation: {
            phrase,
            phraseLanguage: metaContent.phraseLanguage || 'unknown',
            llmProvider: 'unknown',
            llmModel: 'unknown',
            folderName: folder,
            baseFilename: baseName,
            mdFilePath: mdPath,
            htmlFilePath: htmlPath,
            metaFilePath: metaPath,
            markdownContent: mdContent,
            enTranslation: extractTranslation(mdContent, 'en'),
            jaTranslation: extractTranslation(mdContent, 'ja'),
            zhTranslation: extractTranslation(mdContent, 'zh'),
            generationDate: `${folder.slice(0,4)}-${folder.slice(4,6)}-${folder.slice(6,8)}`,
            requestId: `migrated-${Date.now()}-${Math.random()}`
          },
          observability: {
            // 迁移的旧数据，可观测性指标为空
            tokensInput: 0,
            tokensOutput: 0,
            tokensTotal: 0,
            qualityScore: null,
            performanceTotalMs: null,
            performancePhases: '{}',
            qualityChecks: '[]',
            qualityDimensions: '{}',
            qualityWarnings: '[]',
            promptFull: '',
            promptParsed: '{}',
            llmOutput: '',
            metadata: JSON.stringify({ migrated: true })
          },
          audioFiles: [] // 旧记录可能没有音频元数据
        });

        migrated++;
      } catch (err) {
        console.error(`Failed to migrate ${baseName}:`, err.message);
        failed++;
      }
    }
  }

  console.log(`Migration complete: ${migrated} success, ${failed} failed`);
}

// 执行迁移
migrateExistingRecords('./trilingual_records');
```

---

## 📈 查询示例

### 1. 查找质量最高的100条记录

```javascript
const topQuality = dbService.db.prepare(`
  SELECT g.phrase, g.llm_provider, om.quality_score, g.created_at
  FROM generations g
  JOIN observability_metrics om ON g.id = om.generation_id
  WHERE om.quality_score IS NOT NULL
  ORDER BY om.quality_score DESC
  LIMIT 100
`).all();
```

### 2. 对比不同模型的平均质量

```javascript
const modelComparison = dbService.db.prepare(`
  SELECT
    g.llm_provider,
    COUNT(*) as count,
    AVG(om.quality_score) as avg_quality,
    AVG(om.tokens_total) as avg_tokens,
    AVG(om.performance_total_ms) as avg_time_ms
  FROM generations g
  JOIN observability_metrics om ON g.id = om.generation_id
  WHERE g.created_at >= datetime('now', '-7 days')
  GROUP BY g.llm_provider
  ORDER BY avg_quality DESC
`).all();
```

### 3. 全文搜索短语

```javascript
const results = dbService.fullTextSearch('machine learning');
```

### 4. 查找错误率高的时间段

```javascript
const errorTrends = dbService.db.prepare(`
  SELECT
    DATE(created_at) as error_date,
    error_type,
    COUNT(*) as error_count
  FROM generation_errors
  WHERE created_at >= datetime('now', '-30 days')
  GROUP BY error_date, error_type
  ORDER BY error_date DESC, error_count DESC
`).all();
```

---

## 🚀 实施计划

### Phase 1: 基础设施（第1周）

**任务：**
- [x] 数据库schema设计
- [ ] 安装依赖：`npm install better-sqlite3`
- [ ] 创建DatabaseService类
- [ ] 编写初始化脚本
- [ ] 单元测试

**交付物：**
- `database/schema.sql`
- `services/databaseService.js`
- `tests/database.test.js`

### Phase 2: API集成（第2周）

**任务：**
- [ ] server.js集成写入逻辑
- [ ] 错误处理和回滚
- [ ] 性能优化（批量插入、索引调优）
- [ ] 集成测试

**交付物：**
- 修改后的`server.js`
- 性能测试报告

### Phase 3: 查询接口（第3周）

**任务：**
- [ ] 新增API端点：`GET /api/history`
- [ ] 新增API端点：`GET /api/statistics`
- [ ] 新增API端点：`GET /api/search`
- [ ] 前端History面板开发

**交付物：**
- 新API端点
- 前端历史记录页面

### Phase 4: 数据迁移（第4周）

**任务：**
- [ ] 编写迁移脚本
- [ ] 测试迁移流程
- [ ] 执行完整迁移
- [ ] 验证数据完整性

**交付物：**
- `scripts/migrate-to-database.js`
- 迁移报告

### Phase 5: 分析功能（第5周）

**任务：**
- [ ] 实现质量趋势分析
- [ ] 实现成本统计报表
- [ ] 实现模型对比仪表板
- [ ] 数据导出功能

**交付物：**
- 分析仪表板
- 导出功能

---

## 📦 依赖安装

```bash
npm install better-sqlite3
npm install --save-dev @types/better-sqlite3  # TypeScript支持
```

---

## 🔒 备份策略

### 自动备份

```javascript
// 每日备份
const cron = require('node-cron');

cron.schedule('0 2 * * *', () => {
  const dbPath = './data/trilingual_records.db';
  const backupPath = `./backups/db-${Date.now()}.db`;
  fs.copyFileSync(dbPath, backupPath);
  console.log(`[Backup] Created: ${backupPath}`);
});
```

### 数据导出

```sql
-- 导出为CSV
.mode csv
.output generations_export.csv
SELECT * FROM generations;
.output stdout
```

---

## 📊 预期性能

| 操作 | 预期耗时 | 优化目标 |
|------|---------|---------|
| 插入单条记录 | 5-10ms | <5ms |
| 分页查询（20条） | 20-50ms | <20ms |
| 全文搜索 | 50-100ms | <50ms |
| 统计聚合 | 100-200ms | <100ms |
| 数据库大小（1万条） | ~50MB | - |

---

**最后更新**: 2026-02-03
**设计版本**: v1.0
**状态**: ✅ 设计完成，待实施
